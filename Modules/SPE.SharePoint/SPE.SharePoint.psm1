#region Script-Header with Description and Versioning
<######################################################################
# Powershell-Script-Module                                            #
# #####################################################################
# Name:        SPE.SharePoint.psm1                                    #
# Description: This PowerShell-Module contains functions to be used   #
#              for scripts generated by MT AG Ratingen                #
# ################################################################### #
# # Versions:                                                       # #
# ################################################################### #
# Ver. | Author     | Changes                            | Date       #
# ################################################################### #
# 0.1  | S.Josupeit | Initial Release                    | 29.07.2015 #
# 1.2  | S.Krieger  | Fertigstellung XML-Help-File       | 29.10.2015 #
# 1.3  | S.Krieger  | Erweiterungen                   ab | 30.10.2015 #
# 2.0  | S.Krieger  | Umbennenung in SPE.SharePoint.psm1 | 24.11.2016 #
# 2.1  | S.Krieger  | Erweiterungen                   ab | 24.11.2016 #  
######################################################################>
#endregion

#region Version 1.2

#region Functions for CSOM

    #region Function Import-SPEDLL
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    Function Import-SPEDLL{
        [CmdletBinding()]
        param
        (
            [Parameter(Position=0,Mandatory=$true)]
            [System.String]
            $Path = $PathToSharePointDLLs,
            [Parameter(Position=1,Mandatory=$true)]
            [System.String]
            $File
        )
        Begin{
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
        }
        Process
        {
            $filePath = $Path.TrimEnd("\") + "\" + $File
            if(Test-Path $filePath)
            {
                try{
                   Add-Type -Path ($filePath)
                }
	            catch
	            {
                    if($global:ActivateTestLoggingException)
                    {
	                    $exMessage = $_.Exception.Message
	                    $innerException = $_.Exception.InnerException
	                    $info = "Fehler bei Import der DLL '" + $File + "' aus Ordner '" + $Path + "'"
	                    Push-SPEException -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -exMessage $exMessage -innerException $innerException -info $info 
                    }
	            }
            } else {
                lm -level "Critical" -area "misc" -category "Adding" -message "DLL with path $filePath could not be found! Please check if folder $Path and file $File exists." -category $($MyInvocation.MyCommand.Name)
            }
        
        }
        End{}
    }
    #endregion
    #EndOfFunction

    #region Function Import-SPECsomDLLs
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    Function Import-SPECsomDLLs{
        [CmdletBinding()]
        param
        (
            [Parameter(Position=0)]
            [System.String]
            $Path,
            [Switch]$UseDocumentManagement,
            [Switch]$UsePublishing,
            [Switch]$UseSearch,
            [Switch]$UseSearchApplications,
            [Switch]$UseServerRuntime,
            [Switch]$UseTaxonomy,
            [Switch]$UseUserProfiles,
            [Switch]$UseWorkflowServices
        )
        Begin{
            if([String]::IsNullOrEmpty($Path))
            {
                $thisModulePath = (Get-Command $PSCmdlet.MyInvocation.MyCommand.Name.ToString()).Module.ModuleBase.ToString()
                $Path = $thisModulePath.TrimEnd("\") + "\sharepointdlls\"
            }
        }
        Process
        {
            $Path = $Path.TrimEnd("\") + "\"
            Add-Type -Path ($Path + "Microsoft.SharePoint.Client.dll")
            Add-Type -Path ($Path + "Microsoft.SharePoint.Client.Runtime.dll")
            if($UseDocumentManagement)
            {
                $file = "Microsoft.SharePoint.Client.DocumentManagement.dll"
                Import-SPEDLL -Path $Path -File $file
            }
            if($UsePublishing){
                $file = "Microsoft.SharePoint.Client.Publishing.dll"
                Import-SPEDLL -Path $Path -File $file
            }
            if($UseSearch) {
                $file = "Microsoft.SharePoint.Client.Search.dll"
                Import-SPEDLL -Path $Path -File $file
            }
            if($UseSearchApplications){
                $file = "Microsoft.SharePoint.Client.Search.Applications.dll"
                Import-SPEDLL -Path $Path -File $file
            }
            if($UseServerRuntime){
                $file = "Microsoft.SharePoint.Client.ServerRuntime.dll"
                Import-SPEDLL -Path $Path -File $file
            }
            if($UseTaxonomy){
                $file = "Microsoft.SharePoint.Client.Taxonomy.dll"
                Import-SPEDLL -Path $Path -File $file
            }
            if($UseUserProfiles){
                $file = "Microsoft.SharePoint.Client.UserProfiles.dll"
                Import-SPEDLL -Path $Path -File $file
            }
            if($UseWorkflowServices){
                $file = "Microsoft.SharePoint.Client.WorkflowServices.dll"
                Import-SPEDLL -Path $Path -File $file
            }
        }
        End{}
    }
   
    #endregion
    #EndOfFunction

    #region Function Get-SPECsomContext
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    function Get-SPECsomContext {
        [CmdletBinding()]
        param
        (
 		    [Parameter(Position=0, Mandatory=$true)]
		    [ValidateNotNullOrEmpty()]
		    [System.String]
		    $Url,
		    [Parameter(Position=1)]
		    [ValidateNotNull()]
		    [PSCredential]
		    $Credentials,
            [Switch]
            $SPO

       )

        begin 
        {
            Test-SPEAndLoadCsomDLLs
        }

        process 
        {
            if($SPO)
            {
                $credUsername = $Credentials.UserName
                $credSecPass = $Credentials.Password
                $cred = New-Object Microsoft.SharePoint.Client.SharePointOnlineCredentials($credUsername, $credSecPass)
            } else {
                $credUsername = $Credentials.GetNetworkCredential().UserName
                $credDomain = $Credentials.GetNetworkCredential().Domain
                $credSecPass = $Credentials.GetNetworkCredential().SecurePassword
                $cred = New-Object System.Net.NetworkCredential($credUsername, $credSecPass, $credDomain)
            }
            $ctx = New-Object Microsoft.SharePoint.Client.ClientContext($url)
            $ctx.Credentials = $cred

            if(!$ctx.ServerObjectIsNull.Value)
            {
                return $ctx
            }
            else
            {
                return $null
            }
        }
    }
    #endregion
    #EndOfFunction

    #region Function Get-SPECsomWeb
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    function Get-SPECsomWeb {
        [CmdletBinding()]
        param
        (
 		    [Parameter(Position=0, Mandatory=$true)]
		    [ValidateNotNullOrEmpty()]
		    [System.String]
		    $Url,
		    [Parameter(Position=1, Mandatory=$true)]
		    [ValidateNotNull()]
		    [PSCredential]
		    $Credentials,
            [Switch]
            $SPO
       )

        begin 
        {
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
            Test-SPEAndLoadCsomDLLs
        }

        process 
        {
            try{
                if($SPO)
                {
                    $ctx = Get-SPECsomContext -Credentials $Credentials -Url $Url -SPO
                } else {
                    $ctx = Get-SPECsomContext -Credentials $Credentials -Url $Url
                }
                if($ctx)
                {
                    $web = $ctx.Web
                    $ctx.Load($web)
                    $ctx.ExecuteQuery()
                    return $web
                }
                else
                {
                    return $null
                }
            } catch{
	            $exMessage = $_.Exception.Message
	            $innerException = $_.Exception.InnerException
	            if($exMessage -match "401"){
                    lm -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -level Unexpected -message $exMessage
                    return "401"
                } elseif ($exMessage -match "404"){
                    lm -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -level Unexpected -message $exMessage
                    return "404"
                } else {
                    $info = "Fehler bei Erfassen der Website '$Url' in Function 'Get-SPECsomWeb'."
	                Push-SPEException -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -exMessage $exMessage -innerException $innerException -info $info
                    $global:foundErrors = $true
                    return $null
                }
            }
        }
    }
    #endregion
    #EndOfFunction

    #region Function Get-SPECsomSite
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    function Get-SPECsomSite {
        [CmdletBinding()]
        param
        (
 		    [Parameter(Position=0, Mandatory=$true)]
		    [ValidateNotNullOrEmpty()]
		    [System.String]
		    $Url,
		    [Parameter(Position=1, Mandatory=$true)]
		    [ValidateNotNull()]
		    [PSCredential]
		    $Credentials,
            [Switch]$SPO

       )

        begin 
        {
            Test-SPEAndLoadCsomDLLs
        }

        process 
        {
            if($SPO)
            {
                $ctx = Get-SPECsomContext -Credentials $Credentials -Url $Url -SPO
            } else {
                $ctx = Get-SPECsomContext -Credentials $Credentials -Url $Url
            }
            if($ctx)
            {
                $site = $ctx.Site
                $ctx.Load($site)
                $ctx.ExecuteQuery()
                return $site
            }
            else
            {
                return $null
            }
        }
    }
    #endregion
    #EndOfFunction

    #region Function Get-SPECsomList
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    Function Get-SPECsomList
    {
        [CmdletBinding(DefaultParameterSetName="Title")]
        param
        (
		    [Parameter(Position=0, Mandatory=$true)]
		    [ValidateNotNull()]
		    [Microsoft.SharePoint.Client.Web]
		    $Web,
 		    [Parameter(Position=1,ParameterSetName="Title")]
		    [System.String]
		    $ListTitle,
 		    [Parameter(Position=1,ParameterSetName="Id")]
		    [System.String]
		    $ListId
        )
        begin 
        {
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
            Test-SPEAndLoadCsomDLLs
            $ctx = $Web.Context
        }

        process 
        {
            try{
                 if($ListTitle -or $ListId) # ListTitle is set, so return specified list
                {
                   switch($PSCmdlet.ParameterSetName){
                        "Title"{
                            $list = $Web.Lists.GetByTitle($ListTitle)
                            break
                        }
                        "Id"{
                            $list = $web.Lists.GetById($ListId)
                            break
                        }
                    }
                            
                    $ctx.Load($list)
                    $ctx.ExecuteQuery()
                    return $list

                }
                else # ListTitle is not set, so return all lists
                {
                    $lists = $web.Lists
                    $ctx.Load($lists)
                    $ctx.ExecuteQuery()
                    return $lists
                }
            } catch{
                switch($PSCmdlet.ParameterSetName){
                    "Title"{
                        $info = "Fehler bei Erfassen der Liste '$ListTitle'."
                        break
                    }
                    "Id"{
                        $info = "Fehler bei Erfassen der Liste mit Id '$ListId'."
                        break
                    }
                }
                lx -Stack $_ -info $info -Category $LogCat
                $global:foundErrors = $true
                return $null
            }
        }

    }
    #endregion
    #EndOfFunction

    #region Function Get-SPECsomListItems
    Function Get-SPECsomListItems{
        [CmdletBinding()]
        param(
            [Microsoft.SharePoint.Client.List]$List,
            [Microsoft.SharePoint.Client.ClientContext]$Context,
            [guid]$curCorrId = [Guid]::NewGuid()
        )
        Begin{
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)";
            $allItemsQuery = [Microsoft.SharePoint.Client.CamlQuery]::CreateAllItemsQuery();
        }
        Process{
            try{
               # if($Context){
               #     $curCtx = $Context
               # } else {
                    $curCtx = $List.Context
               # }
                $items = $List.GetItems($allItemsQuery)
                $curCtx.Load($items)
                $curCtx.ExecuteQuery()
                return $items
            }
            catch{
                $info = "Error at retrieving listitems"
                lx -Stack $_ -info $info -Category $LogCat -CorrId $curCorrId
            }
        }
        End{}
    }
    #endregion
    #EndOfFunction
 
    #region Function Get-SPECsomListItemsAsArrayList
    Function Get-SPECsomListItemsAsArrayList{
        [CmdletBinding()]
        param(
            [Microsoft.SharePoint.Client.List]$List,
            [Microsoft.SharePoint.Client.ClientContext]$Context,
            [guid]$curCorrId = [Guid]::NewGuid()
        )
        Begin{
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)";
            $allItemsQuery = [Microsoft.SharePoint.Client.CamlQuery]::CreateAllItemsQuery();
        }
        Process{
            try{
                $coll = New-Object System.Collections.ArrayList
                if($Context){
                    $curCtx = $Context
                } else {
                    $curCtx = $List.Context
                }
                $items = Get-SPECsomListItems -List $List -curCorrId $curCorrId
                foreach($item in $items){
                    $curCtx.Load($item)
                    $curCtx.ExecuteQuery()
                    $coll.Add($item) | Out-Null
                }
                return $coll
            }
            catch{
                $info = "Error at retrieving listitems for ArrayList"
                lx -Stack $_ -info $info -Category $LogCat -CorrId $curCorrId
            }
        }
        End{}
    }
    #endregion
    #EndOfFunction

    #region Function Test-SPEAndLoadCsomDLLs
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    Function Test-SPEAndLoadCsomDLLs
    {
        [CmdletBinding()]
        param()
        Begin{}
        Process
        {
            try
            {
                #Testweise Erfassen, ob DLL Microsoft.SharePoint.Client geladen ist.
                [reflection.assembly]::GetAssembly("Microsoft.SharePoint.Client.ClientContext" -as [type]) | out-null
            }
            catch
            {
                #ist nicht geladen, also laden
                Import-SPECsomDLLs
            }
        }
        End{}
    }
    #endregion
    #EndOfFunction

    #region Function Get-SPECredentialsFromCurrentUser
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    Function Get-SPECredentialsFromCurrentUser
    {
        [CmdletBinding()]
        param
        (
            [Switch]$SPO
        )

        begin 
        {
        }
        process
        {
            if($SPO)
            {
                $EmailRegex = '^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,4})$'
                $message = "Bitte Web-Zugangsdaten (im Email-Format) eingeben"
                do{
                    $Credential = Get-Credential -Message $message
                    $message = "Anscheinend wurde der Anmeldename nicht im Email-Format eingegeben. Bitte erneut versuchen."
                } until($Credential.UserName -match $EmailRegex)
            } else {
                $currentUser = [Security.Principal.WindowsIdentity]::GetCurrent()
                $currentUserName = $currentUser.Name
                $Credential = Get-Credential -Message "Bitte Passwort eingeben" -UserName $currentUserName
            }
            return $Credential
        }

    }
    #endregion
    #EndOfFunction

    #region Function Save-SPECredentialsToConfig
    Function Save-SPECredentialsToConfig{
        [CmdletBinding()]
        param(
            [pscredential]$Credential,
            [switch]$SPO
        )
        Begin{
            if(!$Credential){
                if($SPO){
                    $Credential = Get-SPECredentialsFromCurrentUser -SPO
                } else {
                    $Credential = Get-SPECredentialsFromCurrentUser
                }
            }
            $xmlStrCred = [System.Management.Automation.PSSerializer]::Serialize($Credential)
            $xmlCred = Convert-SPEStringToXMLElement -string $xmlStrCred
            $strCred = "'$($xmlCred.OuterXml)'"
            Update-SPEConfigVariable -Name "SPEStoredCred" -Value $strCred -Description "StoredCredentials"
        }
        Process{}
        End{}
        
    }
    #endregion
    #EndOfFunction

    #region Function Approve-SPECredentialsInConfig
    Function Approve-SPECredentialsInConfig{
        [CmdletBinding()]
        param(
            [switch]$SPO
        )
        Begin{}
        Process{
            $result = Get-Variable -Name "SPEStoredCred" -ErrorAction SilentlyContinue
            if($result -eq $null){
                if($SPO){
                    Save-SPECredentialsToConfig -SPO
                } else {
                    Save-SPECredentialsToConfig
                }
            } 
            $credStrXml = $global:SPEStoredCred.TrimEnd("'").TrimStart("'")
            $global:Cred = [System.Management.Automation.PSSerializer]::Deserialize($credStrXml)
        }
        End{}
    }
    #endregion
    #EndOfFunction

    #region Function Remove-SPECredentialsInConfig
    Function Remove-SPECredentialsInConfig{
        [CmdletBinding()]
        param()
        Begin{}
        Process{
            Update-SPEConfigVariable -Name "SPEStoredCred" -Value $null -Description "StoredCredentials"
        }
        End{}
    }
    #endregion
    #EndOfFunction

    #region Function New-SPECsomList
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    Function New-SPECsomList {
        [CmdletBinding()]
        param
        (
		    [Parameter(Position=0, Mandatory=$true)]
		    [ValidateNotNull()]
		    [Microsoft.SharePoint.Client.Web]
		    $Web,
 		    [Parameter(Position=1, Mandatory=$true)]
		    [ValidateNotNullOrEmpty()]
		    [System.String]
		    $ListTitle,
 		    [Parameter(Position=2, Mandatory=$true)]
		    [ValidateNotNullOrEmpty()]
		    [System.String]
		    $ListDescription,
 		    [Parameter(ParameterSetName="TemplateId", Position=3, Mandatory=$true)]
		    [ValidateNotNullOrEmpty()]
		    [ValidateSet(100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,130,140,150,200,201,202,204,207,210,211,212,301,302,303,433,851,1100,1200)]
            [Int]
		    $ListTemplateId = 100,
            [Parameter(ParameterSetName="TemplateName", Position=3, Mandatory=$true)]
            [ValidateSet("Administrator_tasks_list","Announcements_list","Asset_Library","Blog_Categories_list","Blog_Comments_list","Blog_Posts_list","Contacts_list","Custom_grid_for_a_list","Custom_Workflow_Process","Data_Connection_library","Data_sources","Discussion_board","Document_library","Events_list","Gantt_Tasks_list","Generic_list","Issue_tracking","Links_list","List_template_gallery","Master_pages_gallery","Meeting_Agenda_list","Meeting_Attendees_list","Meeting_Decisions_list","Meeting_Objectives_list","Meeting_Series_list","Meeting_text_box","Meeting_Things_To_Bring_list","Meeting_Workspace_Pages_list","No-Code_Workflows","Picture_library","Report_Library","Site_template_gallery","Survey","Tasks_list","User_Information_list","Web_Part_gallery","Wiki_Page_library","Workflow_History","XML_Form_library")]
            [String]$ListTemplateName = "Generic_List"

       )

        begin 
        {
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
            Test-SPEAndLoadCsomDLLs
            $ctx = $Web.Context
        }

        process 
        {
            try{
                $listCreationInfo = New-Object Microsoft.SharePoint.Client.ListCreationInformation
                $listCreationInfo.Title = $ListTitle
                switch($PSCmdlet.ParameterSetName){
                    "TemplateId"{
                        $listCreationInfo.TemplateType = $ListTemplateId
                        break
                    }
                    "TemplateName"{
                        $listCreationInfo.TemplateType = $SPE_ListTempateNamesToIDs.($($ListTemplateName.Replace("_"," ")))
                        break
                    }
                }
                $list = $web.Lists.Add($listCreationInfo)
                $list.Description = $ListDescription
                $list.Update()
                $ctx.Load($list)
                $ctx.ExecuteQuery()
                return $list
            }
	        catch
	        {
                if($global:ActivateTestLoggingException)
                {
	                $exMessage = $_.Exception.Message
	                $innerException = $_.Exception.InnerException
	                $info = "Function: $($MyInvocation.MyCommand)" + "Fehler bei Erzeugen einer neuen Liste mit Titel '" + $ListTitle + "' in Website '" + $Web.Url + "'."
                    $noErrorMessage = "A list, survey, discussion board, or document library with the specified title already exists in this Web site"
	                if($exMessage -match $noErrorMessage){
                        lm -level Unexpected -message "List with title $ListTitle already exists in website." -category $($MyInvocation.MyCommand.Name)
                    } else {
	                    Push-SPEException -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -exMessage $exMessage -innerException $innerException -info $info
                    }
                }
	        }
            finally
            {
                $ctx = $null
            }
        }
    }
    #endregion
    #EndOfFunction

    #region Function Add-SPECsomListField
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    Function Add-SPECsomListField{
        [CmdletBinding()]
        param(
            [Parameter(Mandatory=$true,Position=0)][Microsoft.SharePoint.Client.List]$List,
            [Parameter(Mandatory=$true,Position=1)][String]$FieldDefinitionAsXMLString,
            [Parameter(Mandatory=$false,Position=2)][Array]$FieldOptions,
            [Parameter(Mandatory=$false,Position=2)][Array]$FieldMultiLookup
        )
        Begin{
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
        }
        Process{
            $FieldDefinitionAsXmlElement = Convert-SPEStringToXMLElement -string $FieldDefinitionAsXMLString
            $fieldAttributeName = $FieldDefinitionAsXmlElement.Name
            $curCtx = $list.Context
            try{
                $curFields = $List.Fields
                $curCtx.Load($curFields)
                $curCtx.ExecuteQuery()
                $curField = $curFields | ?{$_.InternalName -eq $fieldAttributeName}
                if($curField -ne $null){
                    lm -category $LogCat -message "Start changing field '$fieldAttributeName' of list $($List.Title)..."
                    $curField.StaticName = $FieldDefinitionAsXmlElement.StaticName
                    $curField.Title = $FieldDefinitionAsXmlElement.DisplayName
                    $curField.Description = $FieldDefinitionAsXmlElement.Description
                    if($FieldDefinitionAsXmlElement.Indexed -eq "TRUE"){
                        $curField.Indexed = $true
                    }
                    if($FieldDefinitionAsXmlElement.EnforceUniqueValues -eq "TRUE"){
                        $curField.EnforceUniqueValues = $true
                    }
                    if($FieldDefinitionAsXmlElement.Hidden -eq "TRUE"){
                        $curField.Hidden = $true
                    }
                    $curField.Update()
                    $curCtx.Load($curField)
                    $curCtx.ExecuteQuery()
                    lm -category $LogCat -message "...finished changing field '$fieldAttributeName' of list $($List.Title)."
                } 
                else {
                    $strCommand = '$List.Fields.AddFieldAsXml($FieldDefinitionAsXMLString, $AddToDefaultView'
                    switch($($FieldOptions.Length)){
                        0{
                            break
                        }
                        1{
                            $strCommand += ',[Microsoft.SharePoint.Client.AddFieldOptions]::' + $FieldOptions[0]
                            break
                        }
                        Default{
                            for($i = 0; $i -lt $($FieldOptions.Length); $i++)
                            {
                                if($i -eq 0){
                                    $strCommand += ',[Microsoft.SharePoint.Client.AddFieldOptions]::' + $FieldOptions[$i]
                                } else {
                                    $strCommand += ' -bor [Microsoft.SharePoint.Client.AddFieldOptions]::' + $FieldOptions[$i]
                                }
                            }
                            break
                        }
                    }
                    $strCommand += ') | out-null'
                    Invoke-Expression $strCommand
                    $List.Update()
                    $curCtx.ExecuteQuery()
                }
            } 
            catch {
	            $info = "Error at adding list field '$fieldAttributeName'"
                lx -Stack $_ -info $info -Category $LogCat
                $global:foundErrors = $true
            }
            finally {
                $curCtx = $null
            }
        }
        End{}
    }
    #endregion
    #EndOfFunction
    
    #region Function New-SPECsomListItem
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    Function New-SPECsomListItem {
        [CmdletBinding()]
        param
        (
 		    [Parameter(Position=0, Mandatory=$true)]
		    [ValidateNotNullOrEmpty()]
		    [Microsoft.SharePoint.Client.List]
		    $List,

		    [Parameter(Position=1)]
		    [ValidateNotNull()]
		    [System.Collections.ArrayList]
		    $FieldValues
        )

        begin 
        {
            Test-SPEAndLoadCsomDLLs
            $ctx = $List.Context
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
        }

        process 
        {
            try{
                $itemCreateInfo = New-Object Microsoft.SharePoint.Client.ListItemCreationInformation
                $fields = $List.Fields
                $ctx.Load($fields)
                $ctx.ExecuteQuery()
                $newitem = $List.AddItem($itemCreateInfo)
                $newitem.Update()
                $ctx.ExecuteQuery()
                foreach($fieldValuePair in $FieldValues)
                {
                    #region reload the newitem for its version is changing after each newitem.update, which will lead to a "version conflict" error
                    try{
                        $ctx.Load($newitem)
                        $ctx.ExecuteQuery()
                    }
                    catch{
                        lx -Stack $_ -info "Error at reloading newitem to prohibit 'Version Conflict' error" -Category $LogCat
                    }
                    #endregion
                    $fieldExistsInList = $true
                    try{
                        $fieldName = $fieldValuePair.First
                        $fieldIsTitleField = $false
                        if($fieldName -ne "Title"){
                            $fieldValue = $fieldValuePair.Second
                            $field = $fields.GetByInternalNameOrTitle($fieldName)
                            $ctx.Load($field)
                            $ctx.ExecuteQuery()
                            #lm -level Medium -category $LogCat -message "Field '$fieldname' exists in list '$($List.Title)' and will be used."
                            #lm -level Medium -category $LogCat -message "Trying to set Field '$fieldname' with value '$fieldValue'."
                        } else {
                            $fieldIsTitleField = $true
                        }
                    }
                    catch{
                        $noError = "does not exist"
                        if($_.Exception.Message -match $noError){
                            #lm -level Medium -category $LogCat -message "Field '$fieldname' does not exist in list '$($List.Title)' and will be ignored."
                        } else {
                            $info = "Error at retrieving Field"
                            lx -Stack $_ -info $info
                        }
                        $fieldExistsInList = $false
                    }
                    if($fieldExistsInList -and !$fieldIsTitleField){
                        try{
                            $fieldType = $field.FieldTypeKind.ToString()
                            switch($fieldType){
                                "Text"{
                                    $newitem[$fieldName] = $fieldValue
                                    $newItem.Update()
                                    break;
                                }
                                "Lookup"{
                                    $curWeb = $List.ParentWeb
                                    $ctx.Load($curWeb)
                                    $ctx.ExecuteQuery()
                                
                                    $fieldSchemaXml = Convert-SPEStringToXMLElement -string $($field.SchemaXml)
                                    $lookupListId = $fieldSchemaXml.List
                                    $lookupList = Get-SPECsomList -Web $curWeb -ListId $lookupListId
                                    if($fieldValue -match ","){
                                        lm -m "lookupvalue has several items separated by ','. splitting up..." -category $LogCat
                                        $CacheArray = New-Object System.Collections.ArrayList
                                        $fieldValueArray = $fieldValue.Split(",")
                                        foreach($el in $fieldValueArray){
                                            lm -m "adding value '$el' to lookupvaluearray..." -category $LogCat
                                            $query = New-Object Microsoft.SharePoint.Client.CamlQuery;
                                            $query.ViewXml = "<View><Query><Where><Eq><FieldRef Name='$fieldname' /><Value Type='Text'>$el</Value></Eq></Where></Query></View>";
                                            $lookupListItems = $lookupList.GetItems($query);
                                            $ctx.Load($lookupListItems);
                                            $ctx.ExecuteQuery();
                                            $flv = new-object Microsoft.SharePoint.Client.FieldLookupValue
                                            $flv.LookupId = $lookupListItems[0].Id.ToString()
                                            $CacheArray.Add($flv)
                                            lm -m "added value '$el' to lookupvaluearray..." -category $LogCat
                                        }
                                        [Microsoft.SharePoint.Client.FieldLookupValue[]]$flvArray = $CacheArray
                                        $newitem[$fieldName] = $flvArray
                                    } 
                                    else {
                                        $query = New-Object Microsoft.SharePoint.Client.CamlQuery;
                                        $query.ViewXml = "<View><Query><Where><Eq><FieldRef Name='$fieldname' /><Value Type='Text'>$fieldvalue</Value></Eq></Where></Query></View>";
                                        $lookupListItems = $lookupList.GetItems($query);
                                        $ctx.Load($lookupListItems);
                                        $ctx.ExecuteQuery();
                                        $lookupItem = $lookupListItems[0];
                                        $lookupItemId = $lookupItem.ID.ToString();
                                        $flv = new-object Microsoft.SharePoint.Client.FieldLookupValue
                                        $flv.LookupId = $lookupListItems[0].Id.ToString()
                                        $CacheArray = New-Object System.Collections.ArrayList
                                        $CacheArray.Add($flv)
                                        [Microsoft.SharePoint.Client.FieldLookupValue[]]$flvArray = $CacheArray
                                        #$fieldValueString = $lookupItem.Id.toString() + ";#" + $lookupItem[$fieldname];
                                        #$newItem[$fieldName] = $fieldValueString
                                        $newItem[$fieldName] = $flvArray
                                    }
                                    $newItem.Update();
                                    break;
                                }
                                "Boolean"{
                                    $newItem[$fieldName] = [System.Convert]::ToBoolean($fieldValue)
                                    $newitem.Update()
                                    break;
                                }
                                "Number"{
                                    $newitem[$fieldName] = [System.Convert]::ToDecimal($fieldValue)
                                    $newItem.Update()
                                    break;
                                }
                                "DateTime"{
                                    $newitem[$fieldName] = [System.Convert]::ToDateTime($fieldValue)
                                    $newItem.Update()
                                    break;
                                }
                                Default{
                                    $newitem[$fieldName] = $fieldValue
                                    $newItem.Update()
                                    break;
                                }
                            }
                        }
                        catch{
                            lx -Stack $_ -info "Error at creating Value for field '$fieldName' with value '$fieldvalue' and type '$fieldtype' on list '$($List.Title)'." -Category $LogCat
                        }
                    }
                }
                lm -m "setting new item to list '$($List.Title)'" -category $LogCat
                $newItem.Update()
                $ctx.ExecuteQuery()
                return $newitem
            }
            catch{
                $noCall = "The list item could not be added or updated because duplicate values were found "
                if($_.Exception.Message -match $noCall){
                    lm  -category $LogCat -message "Item already exists and will not be added again." -level Unexpected
                } else {
                    lx -Stack $_ -info "Error at creating new Item on list '$($List.Title)'." -Category $LogCat
                }
            }
        }
        End{
            $ctx = $null
        }
    }
    #endregion
    #EndOfFunction

    #region Function New-SPECsomLogListItem
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    Function New-SPECsomLogListItem {
        [CmdletBinding()]
        param
        (
		    [Parameter()]
		    [ValidateNotNull()]
		    [System.Collections.ArrayList]
		    $MessageValues
        )

        begin 
        {
            Test-SPEAndLoadCsomDLLs
            $List = $Global:logList
            $curCtx = $List.Context
        }
        process 
        {
            $itemCreateInfo = New-Object Microsoft.SharePoint.Client.ListItemCreationInformation
            $fields = $List.Fields
            $curCtx.Load($fields)
            $curCtx.ExecuteQuery()
            $newitem = $List.AddItem($itemCreateInfo)
            foreach($fieldValuePair in $MessageValues)
            {
                $fieldName = $fieldValuePair.First
                $fieldValue = $fieldValuePair.Second
                $newitem[$fieldName] = $fieldValue
            }
            $newItem.Update()
            $curCtx.ExecuteQuery()
        }
        End{
            $curCtx = $null
        }
    }
    #endregion
    #EndOfFunction

    #region Function Get-SPECsomProperties
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    function Get-SPECsomProperties 
    { 
        [CmdletBinding(DefaultParameterSetName='ClientObject')] 
        param ( 
            # The Microsoft.SharePoint.Client.ClientObject to populate. 
            [Parameter(Mandatory = $true, ValueFromPipeline = $true, Position = 0, ParameterSetName = "ClientObject")] 
            [Microsoft.SharePoint.Client.ClientObject] 
            $object, 
            # The Microsoft.SharePoint.Client.ClientObject that contains the collection object. 
            [Parameter(Mandatory = $true, ValueFromPipeline = $true, Position = 0, ParameterSetName = "ClientObjectCollection")] 
            [Microsoft.SharePoint.Client.ClientObject] 
            $parentObject, 
            # The Microsoft.SharePoint.Client.ClientObjectCollection to populate. 
            [Parameter(Mandatory = $true, ValueFromPipeline = $true, Position = 1, ParameterSetName = "ClientObjectCollection")] 
            [Microsoft.SharePoint.Client.ClientObjectCollection] 
            $collectionObject, 
            # The object properties to populate 
            [Parameter(Mandatory = $true, Position = 1, ParameterSetName = "ClientObject")] 
            [Parameter(Mandatory = $true, Position = 2, ParameterSetName = "ClientObjectCollection")] 
            [string[]] 
            $propertyNames, 
            # The parent object's property name corresponding to the collection object to retrieve (this is required to build the correct lamda expression). 
            [Parameter(Mandatory = $true, Position = 3, ParameterSetName = "ClientObjectCollection")] 
            [string] 
            $parentPropertyName, 
            # If specified, execute the ClientContext.ExecuteQuery() method. 
            [Parameter(Mandatory = $false, Position = 4)] 
            [switch] 
            $executeQuery 
        ) 
        begin 
        {
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
            Test-SPEAndLoadCsomDLLs
        } 
        process { 
            if ($PsCmdlet.ParameterSetName -eq "ClientObject") { 
                $type = $object.GetType() 
            } else { 
                $type = $collectionObject.GetType() 
                if ($collectionObject -is [Microsoft.SharePoint.Client.ClientObjectCollection]) { 
                    $type = $collectionObject.GetType().BaseType.GenericTypeArguments[0] 
                } 
            } 
            $exprType = [System.Linq.Expressions.Expression] 
            $parameterExprType = [System.Linq.Expressions.ParameterExpression].MakeArrayType() 
            $lambdaMethod = $exprType.GetMethods() | ? { $_.Name -eq "Lambda" -and $_.IsGenericMethod -and $_.GetParameters().Length -eq 2 -and $_.GetParameters()[1].ParameterType -eq $parameterExprType } 
            $lambdaMethodGeneric = Invoke-Expression "`$lambdaMethod.MakeGenericMethod([System.Func``2[$($type.FullName),System.Object]])" 
            $expressions = @() 
  
            foreach ($propertyName in $propertyNames) { 
                $param1 = [System.Linq.Expressions.Expression]::Parameter($type, "p") 
                try 
                { 
                    $name1 = [System.Linq.Expressions.Expression]::Property($param1, $propertyName) 
                } 
                catch 
                { 
                    #Write-Error "Instance property '$propertyName' is not defined for type $type"
                    lm -level High -message "Instance property '$propertyName' is not defined for type $type" -category $($MyInvocation.MyCommand.Name)
                    return 
                } 
                $body1 = [System.Linq.Expressions.Expression]::Convert($name1, [System.Object]) 
                $expression1 = $lambdaMethodGeneric.Invoke($null, [System.Object[]] @($body1, [System.Linq.Expressions.ParameterExpression[]] @($param1))) 
                if ($collectionObject -ne $null) 
                { 
                    $expression1 = [System.Linq.Expressions.Expression]::Quote($expression1) 
                } 
                $expressions += @($expression1) 
            } 

            if ($PsCmdlet.ParameterSetName -eq "ClientObject") 
            { 
                $object.Context.Load($object, $expressions) 
                if ($executeQuery) { 
                    try{
                        $object.Context.ExecuteQuery() 
                    } 
                    catch 
                    {
                        if($global:ActivateTestLoggingException)
                        {
                            $exMessage = $_.Exception.Message
                            $innerException = $_.Exception.InnerException
                            $info = "Function: $($MyInvocation.MyCommand)" + "Fehler bei ExecuteQuery in CmdLet 'Get-SPECsomProperties'"
                            Push-SPEException -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -exMessage $exMessage -innerException $innerException -info $info
                        }
                    }
                } 
            } 
            else 
            { 
                $newArrayInitParam1 = Invoke-Expression "[System.Linq.Expressions.Expression``1[System.Func````2[$($type.FullName),System.Object]]]" 
                $newArrayInit = [System.Linq.Expressions.Expression]::NewArrayInit($newArrayInitParam1, $expressions) 
                $collectionParam = [System.Linq.Expressions.Expression]::Parameter($parentObject.GetType(), "cp") 
                $collectionProperty = [System.Linq.Expressions.Expression]::Property($collectionParam, $parentPropertyName) 
                $expressionArray = @($collectionProperty, $newArrayInit) 
                $includeMethod = [Microsoft.SharePoint.Client.ClientObjectQueryableExtension].GetMethod("Include") 
                $includeMethodGeneric = Invoke-Expression "`$includeMethod.MakeGenericMethod([$($type.FullName)])" 
                $lambdaMethodGeneric2 = Invoke-Expression "`$lambdaMethod.MakeGenericMethod([System.Func``2[$($parentObject.GetType().FullName),System.Object]])" 
                $callMethod = [System.Linq.Expressions.Expression]::Call($null, $includeMethodGeneric, $expressionArray) 
                $expression2 = $lambdaMethodGeneric2.Invoke($null, @($callMethod, [System.Linq.Expressions.ParameterExpression[]] @($collectionParam))) 
                $parentObject.Context.Load($parentObject, $expression2) 
                if ($executeQuery) { $parentObject.Context.ExecuteQuery() } 
            } 
        } 
        end { } 
    } 
    #endregion
    #EndOfFunction

    #region Function Set-SPECsomWebProperties
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    function Set-SPECsomWebProperties
    {
        [CmdletBinding()]
        param
        (
		    [Parameter(Position=0, Mandatory=$true)]
		    [ValidateNotNull()]
		    [Microsoft.SharePoint.Client.Web]
		    $Web,
            [Parameter(Position=0, Mandatory=$true)]
            [ValidateNotNull()]
            [System.Collections.ArrayList]
            $Properties
        )
        Begin
        {
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
            Test-SPEAndLoadCsomDLLs
            #Prüfe, ob alle Properties vom Type System.Web.UI.Pair sind
            foreach($Property in $Properties)
            {
                $PropertyBaseTypeName = Get-SPEBaseTypeNameFromObject $Property
                if($PropertyBaseTypeName -ne "System.Web.UI.Pair")
                {
                    lm -level High -category Aborted -area WebSite -message "Ein Item der anzugebenen ArrayList 'Properties' ist nicht vom Type 'System.Web.UI.Pair'." -category $($MyInvocation.MyCommand.Name)
                    break
                }
            }
        }
        Process
        {
            try
            {
                $context = $Web.Context
                $newPropertiesArrayList = new-Object System.Collections.ArrayList
                foreach($Property in $Properties)
                {
                    $PropertyName = $Property.First
                    $PropertyValue = $Property.Second
                    $web.($PropertyName) = $PropertyValue
                    $newPropertiesArrayList.Add($PropertyName)
                }
                $web.Update()
                Get-SPECSOMProperties -object $web -propertyNames ($newPropertiesArrayList.ToArray())
                $context.ExecuteQuery()
                return $web
            }
            catch
            {
                if($global:ActivateTestLoggingException)
                {
	                $exMessage = $_.Exception.Message
	                $innerException = $_.Exception.InnerException
	                $info = "Function: $($MyInvocation.MyCommand)" + "Fehler in Cmdlet 'Set-SPECSOMWebProperties"
	                Push-SPEException -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -exMessage $exMessage -innerException $innerException -info $info
                }
            }
        }
        End{}
    }
    #endregion
    #EndOfFunction

    #region Function Write-SPELogMessageToSharePoint
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    Function Write-SPELogMessageToSharePoint
    {
        [CmdletBinding()]
        param(
            [Parameter(Position=0, Mandatory=$true)]
            [ValidateNotNull()]
            [psobject]$MessageObject
        )
        Begin{
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
#            if(!$global:foundErrors){
                if(!$UrlToLogWeb -or !$LogListName){
                    $Global:LogToSPList = $false
                    $Global:foundErrors = $true
                    lm -message "Logging in SharePoint-Liste nicht möglich! Website und/oder Liste nicht in Config definiert!" -category $($MyInvocation.MyCommand.Name)
                } else {
                    if(!$Global:logList){
                        if($UrlToLogWeb.Contains("sharepoint.com") -or $UrlToLogWeb.Contains("onmicrosoft.com")){ # Url liegt in SharePoint Online
                            if(!$Global:logCredentials){
                                    Approve-SPECredentialsInConfig -SPO
                                    $Global:logCredentials = $Global:Cred
                            }
                            $Global:logWeb = Get-SPECsomWeb -Url $UrlToLogWeb -Credentials $logCredentials -SPO
                        } else { # Url liegt in SharePoint OnPremises
                            if(!$Global:logCredentials){
                                    Approve-SPECredentialsInConfig
                                    $Global:logCredentials = $Global:Cred
                            }
                            $Global:logWeb = Get-SPECsomWeb -Url $UrlToLogWeb -Credentials $logCredentials
                        }
                        if($Global:logWeb){
                            $Global:logList = Get-SPECsomList -Web $Global:logWeb -ListTitle $LogListName
                            if(!$Global:logList){
                                $Global:LogToSPList = $false
                                $Global:foundErrors = $true
                                lm -message "Fehler bei Erfassen der Log-Liste! Logging in SharePoint-Liste nicht möglich!" -category $($MyInvocation.MyCommand.Name)
                            }
                        } else {
                            $Global:LogToSPList = $false
                            $Global:foundErrors = $true
                            lm -message "Fehler bei Erfassen der Log-WebSite! Logging in SharePoint-Liste nicht möglich!" -category $($MyInvocation.MyCommand.Name)
                       }
                    }
                }
#            }
        }
        Process{
#            if(!$global:foundErrors){
                Limit-SPESharePointLogList
                $fieldValues = New-Object System.Collections.ArrayList
                $fieldValues.Add($(New-Object System.Web.UI.Pair("TimeStamp", $MessageObject.TimeStamp))) | Out-Null # Das ursprüngliche 'Title'-Feld wird umbenannt in 'TimeStamp', muss aber mit dem InternalFieldName addressiert werden
                $fieldValues.Add($(New-Object System.Web.UI.Pair("Process", $MessageObject.Process))) | Out-Null 
                $fieldValues.Add($(New-Object System.Web.UI.Pair("Thread", $MessageObject.Thread))) | Out-Null 
                $fieldValues.Add($(New-Object System.Web.UI.Pair("Area", $MessageObject.Area))) | Out-Null 
                $fieldValues.Add($(New-Object System.Web.UI.Pair("Category", $MessageObject.Category))) | Out-Null 
                $fieldValues.Add($(New-Object System.Web.UI.Pair("EventId", $MessageObject.EventId))) | Out-Null 
                $fieldValues.Add($(New-Object System.Web.UI.Pair("Level", $MessageObject.Level))) | Out-Null 
                $fieldValues.Add($(New-Object System.Web.UI.Pair("Message", $MessageObject.Message))) | Out-Null 
                $fieldValues.Add($(New-Object System.Web.UI.Pair("Correlation", $MessageObject.CorrelationId))) | Out-Null 
                New-SPECsomLogListItem -MessageValues $fieldValues
#            }
        }
        End{}
    }
    #endregion
    #EndOfFunction

    #region Function Limit-SPESharePointLogList
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    Function Limit-SPESharePointLogList
    {
        [CmdletBinding()]
        param()
        Begin{
        }
        Process{
            #Reload LogList, instead of getting the existing object
            $list = Get-SPECsomList -Web $Global:logWeb -ListTitle $LogListName
            $listCtx = $list.Context
            $itemCount = $list.ItemCount
            if($itemCount -ge $SPLogMaxItems)
            {
                $query = new-object Microsoft.SharePoint.Client.CamlQuery
                $query.ViewXml = "<View><RowLimit>1000</RowLimit></View>"
                $items = $list.GetItems($query)
                $listCtx.Load($items)
                $listCtx.ExecuteQuery()
                for($i = 0; $i -le ($itemCount - $SPLogMaxItems); $i++){
                    $items[$i].DeleteObject()
                }
                $listCtx.ExecuteQuery()
            }
            $listCtx = $null
            $list = $null
        }
        End{}
    }
    #endregion
    #EndOfFunction

    #region Function Get-SPECsomListView
    Function Get-SPECsomListView{
        [CmdletBinding()]
        param(
            [parameter(Mandatory=$true, ValueFromPipeline=$true)][Microsoft.SharePoint.Client.List]$List,
            [parameter(Mandatory=$true, ValueFromPipeline=$true)][string]$ViewName
        )
        Begin{
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
            $curCtx = $List.Context
        }
        Process{
            try{
                $views = $list.Views
                $curCtx.Load($views)
                $curCtx.ExecuteQuery()

                $view = $null
                $view = $views | ?{$_.Title -eq $ViewName}
                if($view -ne $null){
                    $curCtx.Load($view)
                    $curCtx.ExecuteQuery()
                }
            } catch {
	            $exMessage = $_.Exception.Message
	            $innerException = $_.Exception.InnerException
	            $info = "Fehler bei Erfassen eines Views mit Namen '$ViewName' auf Liste $($List.Title)."
	            Push-SPEException -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -exMessage $exMessage -innerException $innerException -info $info
            }
            return $view

        }
        End{
            $curCtx = $null
        }
    }
    #endregion
    #EndOfFunction

    #region Function New-SPECsomListView
    Function New-SPECsomListView{
        [CmdletBinding()]
        param(
            [parameter(Mandatory=$true, ValueFromPipeline=$true)]
            [Microsoft.SharePoint.Client.List]$List,
            [parameter(ValueFromPipeline=$true, ParameterSetName="Separate")]
            [string]$ViewName,
            [parameter(ValueFromPipeline=$true, ParameterSetName="Separate")]
            [bool]$DefaultView,
            [parameter(ValueFromPipeline=$true, ParameterSetName="Separate")]
            [bool]$Paged,
            [parameter(ValueFromPipeline=$true, ParameterSetName="Separate")]
            [bool]$PersonalView,
            [parameter(ValueFromPipeline=$true, ParameterSetName="Separate")]
            [string]$Query,
            [parameter(ValueFromPipeline=$true, ParameterSetName="Separate")]
            [int]$RowLimit,
            [parameter(ValueFromPipeline=$true, ParameterSetName="Separate")]
            [string[]]$ViewFields,
            [parameter(ValueFromPipeline=$true, ParameterSetName="Separate")]
            [ValidateSet("none","html","grid","calendar","recurrence","chart","gantt")]
            [string]$ViewType,
            [parameter(ValueFromPipeline=$true, ParameterSetName="Object")]
            [PSObject]$viewObject,
            [Boolean]$Overwrite=$false
        )
        Begin{
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
            $curCtx = $List.Context
        }
        Process{
            if($PSCmdlet.ParameterSetName -eq "Object"){
                $ViewName = $viewObject.ViewName
                $DefaultView = $viewObject.DefaultView
                $Paged = $viewObject.Paged
                $PersonalView = $viewObject.PersonalView
                $Query = $viewObject.Query
                $RowLimit = $viewObject.RowLimit
                $ViewFields = $viewObject.ViewFields
                $ViewType = $viewObject.ViewType
            }
            lm -Category $LogCat -message "Testing for view '$ViewName' on list '$($List.Title)'..."
            $view = Get-SPECsomListView -List $list -ViewName $ViewName
            if($view -ne $null)
            {
                lm -Category $LogCat -message "View '$ViewName' already exists on list '$($List.Title)'."
                if($Overwrite){
                    lm -Category $LogCat -message "Existing view '$ViewName' will be updated"
                    $view = Update-SPECsomListView -List $List -ViewName $ViewName -DefaultView $DefaultView -Paged $Paged -Query $Query -RowLimit $RowLimit -ViewFields $ViewFields
                }
            } 
            else 
            {
                lm -Category $LogCat -message "View '$ViewName' does not exist and will be created now."
                try{
                    switch($ViewType) {
                        "none"{$ViewTypeKind = [Microsoft.SharePoint.Client.ViewType]::None}
                        "html"{$ViewTypeKind = [Microsoft.SharePoint.Client.ViewType]::Html}
                        "grid"{$ViewTypeKind = [Microsoft.SharePoint.Client.ViewType]::Grid}
                        "calendar"{$ViewTypeKind = [Microsoft.SharePoint.Client.ViewType]::Calendar}
                        "recurrence"{$ViewTypeKind = [Microsoft.SharePoint.Client.ViewType]::Recurrence}
                        "chart"{$ViewTypeKind = [Microsoft.SharePoint.Client.ViewType]::Chart}
                        "gantt"{$ViewTypeKind = [Microsoft.SharePoint.Client.ViewType]::Gantt}
                    }
                    $vCreation = New-Object Microsoft.SharePoint.Client.ViewCreationInformation
                    $vCreation.Paged = $Paged
                    $vCreation.PersonalView = $PersonalView
                    $vCreation.Query = $Query
                   
                    $vCreation.RowLimit = $RowLimit
                    $vCreation.SetAsDefaultView = $DefaultView
                    $vCreation.Title = $ViewName
                    $vCreation.ViewFields = $ViewFields
                    $vCreation.ViewTypeKind = $ViewTypeKind
                    $views = $List.Views
                    $curCtx.Load($views)
                    $curCtx.ExecuteQuery()
                    $view = $views.Add($vCreation)
		            $view.ViewQuery = $Query
		            $view.Update()
		            $List.Update()
                    $curCtx.ExecuteQuery()
                    if($viewObject.PSObject.Properties.Name -match "ViewData"){
                        $curCtx.Load($view)
                        $curCtx.ExecuteQuery()
                        $view.ViewData = $viewObject.ViewData
                        $view.Update()
                        $List.Update()
                        $curCtx.Load($view)
                        $curCtx.ExecuteQuery()
                    }
                } catch {
	                $info = "Fehler bei Erzeugen eines neuen Views mit Namen '$ViewName' auf Liste $($List.Title)."
                    lx -Stack $_ -info $info -Category $LogCat
                }
            }
            return $view
        }
        End{
            $curCtx = $null
        }
    }
    #endregion
    #EndOfFunction

    #region Function New-SPECsomListViewFromXml
    Function New-SPECsomListViewFromXml{
        [CmdletBinding()]
        param(
            [parameter(Mandatory=$true)]
            [Microsoft.SharePoint.Client.List]$List,
            [parameter(Mandatory=$true,ParameterSetName="String")]
            [string]$XmlString,
            [parameter(Mandatory=$true,ParameterSetName="Object")]
            [System.Xml.XmlElement]$XmlElement,
            [Boolean]$Overwrite
        )
        Begin{
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
        }
        Process{
            if($PSCmdlet.ParameterSetName -eq "String"){
                $xmlObject = Convert-SPEStringToXMLElement -string $XmlString
            } else {
                $xmlObject = $XmlElement
            }
            lm -Category $LogCat -message "Start conversion of XML data to create new view '$($xmlObject.Name)' on list '$($List.Title)'..."
            $viewObject = New-Object PSObject
            $viewObject | Add-Member -MemberType NoteProperty -Name ViewName -Value $($xmlObject.Name)
            $viewObject | Add-Member -MemberType NoteProperty -Name DefaultView -Value $([System.Convert]::ToBoolean($xmlObject.SetAsDefaultView))
            $viewObject | Add-Member -MemberType NoteProperty -Name Paged -Value $([System.Convert]::ToBoolean($xmlObject.Paged))
            $viewObject | Add-Member -MemberType NoteProperty -Name PersonalView -Value $([System.Convert]::ToBoolean($xmlObject.PersonalView))
            $viewObject | Add-Member -MemberType NoteProperty -Name Query -Value $($xmlObject.Query.InnerXml)
            $viewObject | Add-Member -MemberType NoteProperty -Name RowLimit -Value $([System.Convert]::ToInt32($xmlObject.RowLimit))
            $viewObject | Add-Member -MemberType NoteProperty -Name ViewFields -Value $($xmlObject.ViewFields.ChildNodes | %{$_.Name})
            $viewObject | Add-Member -MemberType NoteProperty -Name ViewType -Value $($xmlObject.ViewType)
            if($xmlObject.ViewData -ne $null){
                $viewObject | Add-Member -MemberType NoteProperty -Name ViewData -Value $($xmlObject.ViewData.InnerXml)
            }
            $newView = New-SPECsomListView -List $List -viewObject $viewObject -Overwrite $Overwrite
            return $newView
        }
        End{
        }
    }
    #endregion
    #EndOfFunction

    #region Function Update-SPECsomListView
    Function Update-SPECsomListView{
        [CmdletBinding()]
        param(
            [parameter(Mandatory=$true, ValueFromPipeline=$true)]
            [Microsoft.SharePoint.Client.List]$List,
            [parameter(ValueFromPipeline=$true, ParameterSetName="Separate")]
            [string]$ViewName,
            [parameter(ValueFromPipeline=$true, ParameterSetName="Separate")]
            [bool]$DefaultView,
            [parameter(ValueFromPipeline=$true, ParameterSetName="Separate")]
            [bool]$Paged,
            [parameter(ValueFromPipeline=$true, ParameterSetName="Separate")]
            [string]$Query,
            [parameter(ValueFromPipeline=$true, ParameterSetName="Separate")]
            [int]$RowLimit,
            [parameter(ValueFromPipeline=$true, ParameterSetName="Separate")]
            [string[]]$ViewFields,
            [parameter(ParameterSetName="Object")][PSObject]$viewObject
        )
        Begin{
            $curCtx = $list.Context
        }
        Process{
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
            if($PSCmdlet.ParameterSetName -eq "Object"){
                $ViewName = $viewObject.ViewName
                $DefaultView = $viewObject.DefaultView
                $Paged = $viewObject.Paged
                $Query = $viewObject.Query
                $RowLimit = $viewObject.RowLimit
                $ViewFields = $viewObject.ViewFields
            }
            lm -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -message "Testing for view '$ViewName' on list '$($List.Title)'..."
            $view = Get-SPECsomListView -List $list -ViewName $ViewName
            if($view -ne $null)
            {
                lm -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -message "View '$ViewName' was found and will be updated now..."
                $view.Paged = $Paged
                $view.ViewQuery = $Query
                $view.RowLimit = $RowLimit
                $view.DefaultView = $DefaultView
                $view.ViewFields.RemoveAll()
                ForEach ($vf in $ViewFields) {
                    $view.ViewFields.Add($vf)
                }
                $view.Update()
                $List.Update()
                $curCtx.ExecuteQuery()
                lm -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -message "View '$ViewName' was succesfully updated."
            } else {
                lm -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -message "View '$ViewName' could not be found."
            }
        }
        End{
            $curCtx = $null
        }
    }
    #endregion
    #EndOfFunction

    #region Function Update-SPECsomListViewFromXml
    Function Update-SPECsomListViewFromXml{
        [CmdletBinding()]
        param(
            [parameter(Mandatory=$true)]
            [Microsoft.SharePoint.Client.List]$List,
            [parameter(Mandatory=$true,ParameterSetName="String")]
            [string]$XmlString,
            [parameter(Mandatory=$true,ParameterSetName="Object")]
            [System.Xml.XmlElement]$XmlElement
        )
        Begin{
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
        }
        Process{
            if($PSCmdlet.ParameterSetName -eq "String"){
                $xmlObject = Convert-SPEStringToXMLElement -string $XmlString
            } else {
                $xmlObject = $XmlElement
            }
            lm -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -message "Start conversion of XML data to update view '$($xmlObject.Name)' on list '$($List.Title)'..."
            $viewObject = New-Object PSObject
            $viewObject | Add-Member -MemberType NoteProperty -Name ViewName -Value $($xmlObject.Name)
            $viewObject | Add-Member -MemberType NoteProperty -Name DefaultView -Value $([System.Convert]::ToBoolean($xmlObject.SetAsDefaultView))
            $viewObject | Add-Member -MemberType NoteProperty -Name Paged -Value $([System.Convert]::ToBoolean($xmlObject.Paged))
            $viewObject | Add-Member -MemberType NoteProperty -Name Query -Value $($xmlObject.Query.OuterXml)
            $viewObject | Add-Member -MemberType NoteProperty -Name RowLimit -Value $([System.Convert]::ToInt32($xmlObject.RowLimit.InnerXml))
            $viewObject | Add-Member -MemberType NoteProperty -Name ViewFields -Value $($xmlObject.ViewFields.ChildNodes | %{$_.Name})
            lm -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -message "...finished converting XML data for view '$($xmlObject.Name)' on list '$($List.Title)'."
            $view = Update-SPECsomListView -List $List -viewObject $viewObject
            return $view
        }
        End{}
    }
    #endregion
    #EndOfFunction

#endregion

#region Functions for SharePoint (OnPremises)

	#region Function Step-SPEThroughDirectorySubFolders
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
	Function Step-SPEThroughDirectorySubFolders
	{
		[CmdletBinding()]
		Param(
			[System.IO.DirectoryInfo]$directoryFolder,
			[Microsoft.SharePoint.SPFolder]$targetSPFolder
		)
		Begin{
			$directoryFolderPath = $directoryFolder.FullName
			#$folderRelativePath = $folderpath.Replace($directoryRoot,"")
		}
		Process{
			#region Copy current files from current directory
			$files = Get-SPEDirectoryFiles -folder $directoryFolder
			if($files)
			{
				$resultBasetype = Get-SPEBaseTypeNameFromObject -object $files
				switch($resultBasetype)
				{
					# variable $files contains multiple Items
					"Array"{	
						foreach($file in $files)
						{
							Copy-SPEFileFromDirectoryToSPFolder -sourceFile $file -directoryFolder $directoryFolder -targetSPFolder $targetSPFolder
						}
						break
					}
					# variable $files contains one single Item
					"FileSystemInfo"{ 
						$file = $files
						Copy-SPEFileFromDirectoryToSPFolder -sourceFile $file -directoryFolder $directoryFolder -targetSPFolder $targetSPFolder
						break
					}
					# something else resulting from an error
					"Default"{
						if($global:ActivateTestLoggingException){lm -message "An error occured at determination of files from folder '$directoryFolderPath'." -category $($MyInvocation.MyCommand.Name)}
						break
					}
				}
			}
			#endregion
				
			#region Iterating subfolders
			$directorySubFolders = Get-SPEDirectorySubfolders -folder $directoryFolder
				
			if($directorySubFolders)
			{
				$resultBasetype = Get-SPEBaseTypeNameFromObject -object $directorySubFolders
				switch($resultBasetype)
				{
					# variable $subFolders contains multiple Items
					"Array"{
						foreach($directorySubFolder in $directorySubFolders)
						{
							$subFolderName = $directorySubFolder.FullName.Split("\")[-1]
							if(($newSPFolder = Test-SPEAndSetSPFolder -subFolderName $subFolderName -parentSPFolder $targetSPFolder) -ne $null)
							{
								# Going one level deeper
								Step-SPEThroughDirectorySubFolders -directoryFolder $directorySubFolder -targetSPFolder $newSPFolder
							}
							else
							{
								if($global:ActivateTestLoggingException){lm -message "Error at determing subfolder '$subFolderName'. Skipping this Folder." -category $($MyInvocation.MyCommand.Name)}
							}
						}
						break
					}
					# variable $subFolders contains one single Item
					"FileSystemInfo"{ 
						$directorySubFolder = $directorySubFolders
						$subFolderName = $directorySubFolder.FullName.Split("\")[-1]
						if(($newSPFolder = Test-SPEAndSetSPFolder -subFolderName $subFolderName -parentSPFolder $targetSPFolder) -ne $null)
						{
							# Going one level deeper
							Step-SPEThroughDirectorySubFolders -directoryFolder $directorySubFolder -targetSPFolder $newSPFolder
						} else {
							if($global:ActivateTestLoggingException){lm -message "Error at determing subfolder '$subFolderName'. Skipping this Folder." -category $($MyInvocation.MyCommand.Name)}
						}
						break
					}
					# something else resulting from an error
					"Default"{
						if($global:ActivateTestLoggingException){lm -message "An error occured at determination of subfolders from folder '$directoryFolderPath'." -category $($MyInvocation.MyCommand.Name)}
						break
					}
				}
			}
			#endregion
		}
	}
	#endregion
    #EndOfFunction
		
	#region Function Test-SPEAndSetSPFolder
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
	Function Test-SPEAndSetSPFolder
	{
		[CmdletBinding()]
		Param(
			[String]$subFolderName,
			[Microsoft.SharePoint.SPFolder]$parentSPFolder
		)
		Begin{
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
		}
		Process{
			$newSPFolder = $null
			try
			{
				#$subFolderName = $directorySubFolder.Name
				lm -message "Testing for Subfolder '$subFolderName'..." -category $($MyInvocation.MyCommand.Name)
				if(($newSPFolder = $targetSPFolder.SubFolders[$subFolderName]) -eq $null){
					lm -message "...Folder does not exist and will be created." -category $($MyInvocation.MyCommand.Name)
					$newSPFolder = $targetSPFolder.SubFolders.Add($subFolderName)
					$newSPFolderURL = $newSPFolder.ServerRelativeUrl
					Write-SPEReportMessage -message "Created SPFolder '$newSPFolderURL'" -category $($MyInvocation.MyCommand.Name)
				} else {
					lm -message "...Folder exists an will be used." -category $($MyInvocation.MyCommand.Name)
				}
			}
	        catch
	        {
                if($global:ActivateTestLoggingException)
                {
	                $exMessage = $_.Exception.Message
	                $innerException = $_.Exception.InnerException
	                $info = "Function: $($MyInvocation.MyCommand)" + "Error at Testing for SPFolder '$subFolderName'."
	                Push-SPEException -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -exMessage $exMessage -innerException $innerException -info $info
                }
	        }
			return $newSPFolder
				
		}
	}
	#endregion
    #EndOfFunction
		
	#region Function Copy-SPEFileFromDirectoryToSPFolder
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
	Function Copy-SPEFileFromDirectoryToSPFolder
	{
		[CmdletBinding()]
		Param(
			[System.IO.FileInfo]$sourceFile,
			[System.IO.DirectoryInfo]$directoryFolder,
			[Microsoft.SharePoint.SPFolder]$targetSPFolder
		)
		Begin{
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
		}
		Process{
			$fileName = $sourceFile.Name
			$filePath = $sourceFile.FullName
			$SPFolderUrl = $targetSPFolder.Url
			$dirPath = $directoryFolder.FullName
			$fileLastWriteTimeUTC = $sourceFile.LastWriteTimeUTC
			try{
				if($global:ActivateTestLoggingVerbose){lm -message "Found file '$filePath' in directory '$dirPath'." -category $($MyInvocation.MyCommand.Name)}
				if($global:ActivateTestLoggingVerbose){lm -message "Determing if file already exists in Library-Folder '$SPFolderUrl'..." -category $($MyInvocation.MyCommand.Name)}
				$doCopy = $true
				$doUpdate = $false
				if( ($spFile = $targetSPFolder.Files[$fileName]) -ne $null)
				{
					if($global:ActivateTestLoggingVerbose){lm -message "File exists. Comparing 'Last Modification TimeStamps'..." -category $($MyInvocation.MyCommand.Name)}
					# file exists. check for lastmodified-property
					$spFileLastModified = $spFile.TimeLastModified
					if($spFileLastModified -gt $fileLastWriteTimeUTC)
					{
					    if($global:ActivateTestLoggingVerbose){lm -message "Corresponding file to '$filePath' in SPFolder '$SPFolderUrl' is newer than the sourcefile." -category $($MyInvocation.MyCommand.Name)}
						if($global:ActivateTestLoggingVerbose){lm -message "Skipping copying the sourcefile." -category $($MyInvocation.MyCommand.Name)}
						$doCopy = $false
					} else {
						$doUpdate = $true
					}
				}
				if($doCopy){
					if($global:ActivateTestLoggingVerbose){lm -message "Copying file '$filePath' from directory '$dirPath' to SPFolder '$SPFolderUrl'..." -category $($MyInvocation.MyCommand.Name)}
					$fileStream = $sourceFile.OpenRead()
					[Microsoft.SharePoint.SPFile]$spFile = $targetSPFolder.Files.Add($SPFolderUrl + "/" + $fileName, $fileStream, $true)
					$fileStream.Close()
					if($doUpdate)
					{
						if($global:ActivateTestLoggingVerbose){Write-SPEReportMessage -message "Updated file '$filePath' from directory '$dirPath' to SPFolder '$SPFolderUrl'..." -category $($MyInvocation.MyCommand.Name)}
					}
					else
					{
						if($global:ActivateTestLoggingVerbose){Write-SPEReportMessage -message "Copied file '$filePath' from directory '$dirPath' to SPFolder '$SPFolderUrl'..."}
					}
				}
			}
			catch
	        {
                if($global:ActivateTestLoggingException)
                {
	                $exMessage = $_.Exception.Message
	                $innerException = $_.Exception.InnerException
	                $info = "Function: $($MyInvocation.MyCommand)" + "Error at copying file '$filePath' from directory '$dirPath' to SPFolder '$SPFolderUrl'"
	                Push-SPEException -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -exMessage $exMessage -innerException $innerException -info $info
                }
	        }
		}
	}
	#endregion
    #EndOfFunction
		
	#region Function Remove-SPEEmptySPListSubfolders
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
	function Remove-SPEEmptySPListSubfolders
	{
        [CmdletBinding()]
        param
        (
			[Microsoft.SharePoint.SPFolder]$sourceFolder
		)

        begin {
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
        }

        process {
			lm -area "SPFolder" -category "Determining" -CorrelationId $CorrelationID -level "Verbose" -message "Prüfe, ob SPFolder '$($sourceFolder.Name)' leer ist und gelöscht werden kann." -category $($MyInvocation.MyCommand.Name)
			$folderRelativeUrl = $sourceFolder.ServerRelativeUrl
			$folderName = $sourceFolder.Name
			if(!($sourceFolder.ServerRelativeUrl -match "/Forms"))
			{
				$NoFilesInFolder = $false
				$NoSubFoldersInFolder = $false
				if($global:ActivateTestLoggingVerbose){lm -area "SPItem" -category "Determining" -CorrelationId $CorrelationID -level "Verbose" -message "Prüfe, ob keine Items vorhanden sind..." -category $($MyInvocation.MyCommand.Name)}
				if($sourceFolder.Items.Count -eq 0)
				{
					if($global:ActivateTestLoggingVerbose){lm -area "SPItem" -category "Determining" -CorrelationId $CorrelationID -level "Verbose" -message "Es sind keine Items vorhanden." -category $($MyInvocation.MyCommand.Name)}
					$NoFilesInFolder = $true
				}
				else 
				{
					if($global:ActivateTestLoggingVerbose){lm -area "SPItem" -category "Determining" -CorrelationId $CorrelationID -level "Verbose" -message "Es sind Items vorhanden. Ordner kann nicht gelöscht werden." -category $($MyInvocation.MyCommand.Name)}
				}
				if($global:ActivateTestLoggingVerbose){lm -area "SPFolder" -category "Determining" -CorrelationId $CorrelationID -level "Verbose" -message "Prüfe, ob keine SubFolders vorhanden sind..." -category $($MyInvocation.MyCommand.Name)}
				if($sourceFolder.SubFolders.Count -eq 0)
				{
					if($global:ActivateTestLoggingVerbose){lm -area "SPFolder" -category "Determining" -CorrelationId $CorrelationID -level "Verbose" -message "Es sind keine SubFolder vorhanden." -category $($MyInvocation.MyCommand.Name)}
					$NoSubFoldersInFolder = $true
				} else {
					foreach($subFolder in $sourceFolder.SubFolders)
					{
						if($global:ActivateTestLoggingVerbose){lm -area "SPFolder" -category "Determining" -CorrelationId $CorrelationID -level "Verbose" -message "Es sind SubFolder vorhanden. Iteriere tiefer..." -category $($MyInvocation.MyCommand.Name)}
						Remove-SPEEmptySPListSubfolders -sourceFolder $subFolder
						if($global:ActivateTestLoggingVerbose){lm -area "SPFolder" -category "Determining" -CorrelationId $CorrelationID -level "Verbose" -message "Rücksprung nach Iteration. Überprüfe erneut auf vorhandene SubFolder..." -category $($MyInvocation.MyCommand.Name)}
						if($sourceFolder.subFolders.Count -eq 0)
						{
							if($global:ActivateTestLoggingVerbose){lm -area "SPFolder" -category "Determining" -CorrelationId $CorrelationID -level "Verbose" -message "Keine weiteren SubFolder vorhanden." -category $($MyInvocation.MyCommand.Name)}
							$NoSubFoldersInFolder = $true
						}
						else
						{
							if($global:ActivateTestLoggingVerbose){lm -area "SPFolder" -category "Determining" -CorrelationId $CorrelationID -level "Verbose" -message "Es sind weitere SubFolder vorhanden. Folder kann nicht gelöscht werden." -category $($MyInvocation.MyCommand.Name)}
						}
					}
				}
				if($NoFilesInFolder -and -$NoSubFoldersInFolder)
				{
					if($global:ActivateTestLoggingVerbose){lm -area "SPFolder" -category "Removing" -CorrelationId $CorrelationID -level "Verbose" -message "Folder '$folderName' besitzt keine Items oder SubFolder und kann gelöscht werden." -category $($MyInvocation.MyCommand.Name)}
					$parentFolder = $sourceFolder.ParentFolder
					if($global:ActivateTestLoggingVerbose){lm -area "SPFolder" -category "Removing" -CorrelationId $CorrelationID -level "Verbose" -message "Lösche Folder '$folderName'..." -category $($MyInvocation.MyCommand.Name)}
					if(!$TestModus)
					{
						$parentFolder.SubFolders.Delete($sourceFolder)
					}
					if($global:ActivateTestLoggingVerbose){lm -area "SPFolder" -category "Removed" -CorrelationId $CorrelationID -level "Verbose" -message "Folder '$folderName' wurde gelöscht..." -category $($MyInvocation.MyCommand.Name)}
				}
			} else {
				if($global:ActivateTestLoggingVerbose){lm -area "SPFolder" -category "Determining" -CorrelationId $CorrelationID -level "Medium" -message "Aktuelle Folder ist der FORMS-Folder" -category $($MyInvocation.MyCommand.Name)}
			}
		}
    }
	#endregion
    #EndOfFunction

	#region Function Compare-SPESPFolderWithDirectoryAndDeleteMatchesInSPFolder
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
	function Compare-SPESPFolderWithDirectoryAndDeleteMatchesInSPFolder
	{
        [CmdletBinding()]
        param
        (
			[Microsoft.SharePoint.SPFolder]$sourceFolder,
			[String]$directoryRoot
		)

        begin {
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
			$folderRelativeUrl = $sourceFolder.ServerRelativeUrl
        }

        process {
			if(!($sourceFolder.ServerRelativeUrl -match "/Forms"))
			{
				if($sourceFolder.Files.Count -gt 0)
				{
					$filesToDelete = New-Object System.Collections.ArrayList
					$files = $sourceFolder.Files
					foreach($file in $files)
					{
						$fileName = $file.name
						if($global:ActivateTestLoggingVerbose){Write-Host "filename to delete is $filename"}
						if(!(Test-SPESPFileExistsInDirectory -SPFile $file -directoryRoot $directoryRoot))
						{
							$fileName = $file.Name
							if($global:ActivateTestLoggingVerbose){lm -message "Collecting file '$fileName' for Deletion" -category $($MyInvocation.MyCommand.Name)}
							$filesToDelete.Add($file)
						}
					}
					if($filesToDelete.Count -gt 0)
					{
						foreach($file in $filesToDelete)
						{
							$fileName = $file.Name
							if($global:ActivateTestLoggingVerbose){lm -message "Deleting file '$fileName'..." -category $($MyInvocation.MyCommand.Name)}
							$sourceFolder.Files.Delete($file)
							if($global:ActivateTestLoggingVerbose){Write-SPEReportMessage -message "Deleted file '$fileName' from SPFolder '$folderRelativeUrl'" -category $($MyInvocation.MyCommand.Name)}
						}
					}
				}
				if($sourceFolder.SubFolders.Count -gt 0)
				{
					foreach($subFolder in $sourceFolder.SubFolders)
					{
						$subfolderSRU = $subFolder.ServerRelativeUrl
						Compare-SPESPFolderWithDirectoryAndDeleteMatchesInSPFolder -sourceFolder $subFolder -directoryRoot $directoryRoot
					}
				}
				if(!(Test-SPESPFolderExistsInDirectory -SPFolder $sourceFolder -directoryRoot $directoryRoot) -and ($sourceFolder.files -eq $null))
				{
					$folderName = $sourceFolder.Name
					$folderUrl = $sourceFolder.ServerRelativeUrl
					if($global:ActivateTestLoggingVerbose){lm -message "Folder '$folderName' does not exist in Directory and will now be deleted in Library." -category $($MyInvocation.MyCommand.Name)}
					$parentFolder = $sourceFolder.ParentFolder
					$parentFolder.SubFolders.Delete($sourceFolder)
					if($global:ActivateTestLoggingVerbose){Write-SPEReportMessage -message "Deleted SPFolder '$folderUrl'."}
				}
			} else {
				if($global:ActivateTestLoggingVerbose){lm -message "Current Folder is FORMS-Folder" -category $($MyInvocation.MyCommand.Name)}
			}
		}
    }
	#endregion
    #EndOfFunction

	#region Function Test-SPESPFileExistsInDirectory
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
	Function Test-SPESPFileExistsInDirectory
	{
		[CmdletBinding()]
		Param(
			[Microsoft.SharePoint.SPFile]$SPFile,
			[String]$directoryRoot
		)
		Begin{
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
			$relativeFilePath = $spFile.ServerRelativeUrl.TrimStart("/")
			$relativeFilePath = $relativeFilePath.Replace($dsTargetListName,"")
			if($dsTargetFolderListRelativePath -ne "/")
			{
				$relativeFilePath = $relativeFilePath.Replace($dsTargetFolderListRelativePath,"")
			}
			$relativeFilePath = $relativeFilePath.Replace("/","\")
			$fullFilePath = $dsSourceFolder + $relativeFilePath
		}
		Process{
			$fileExists = $false
			if($global:ActivateTestLoggingVerbose){lm -message "Determining if File '$fullFilePath' exists in directory..." -category $($MyInvocation.MyCommand.Name)}
			if((Test-Path -Path $fullFilePath))
			{
				$fileExists = $true
			}
			return $fileExists
		}
	}
	#endregion
    #EndOfFunction
		
	#region Function Test-SPESPFolderExistsInDirectory
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
	Function Test-SPESPFolderExistsInDirectory
	{
		[CmdletBinding()]
		Param(
			[Microsoft.SharePoint.SPFolder]$SPFolder,
			[String]$directoryRoot
		)
		Begin{
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
			$relativeFolderPath = $spFolder.ServerRelativeUrl.TrimStart("/")
			$relativeFolderPath = $relativeFolderPath.Replace($dsTargetListName,"")
			if($dsTargetFolderListRelativePath -ne "/")
			{
				$relativeFolderPath = $relativeFolderPath.Replace($dsTargetFolderListRelativePath,"")
			}
			$relativeFolderPath = $relativeFolderPath.Replace("/","\")
			$fullFolderPath = $dsSourceFolder + $relativeFolderPath
		}
		Process{
			if($global:ActivateTestLoggingVerbose){lm -message "Determining if Folder '$fullFolderPath' exists in Directory" -category $($MyInvocation.MyCommand.Name)}
			$folderExists = $false
			if((Test-Path -Path $fullFolderPath))
			{
				$folderExists = $true
			}
			return $folderExists
		}
	}
	#endregion
    #EndOfFunction
		
	#region Function Get-SPESPListSubfolders
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
	function Get-SPESPListSubfolders
	{
        [CmdletBinding()]
        param
        ([Microsoft.SharePoint.SPFolder]$folder)

        begin {
        }

        process {
			$subFolders = $null
			if($folder.Subfolders.Count -gt 0)
			{
				$subFolders = $folder.SubFolders
			}
			return $subFolders
		}
    }
	#endregion
    #EndOfFunction

	#region Function Test-SPEAndSetSPWeb
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
	function Test-SPEAndSetSPWeb
	{
#        EXAMPLE
#        $web = Test-SPEAndSetSPWeb -url "http://portal/website" -name "TestSite" -treeViewEnabled $false
        [CmdletBinding()]
        param
        (
			[String]$Url,
			[String]$Name,
            [String]$WebTemplate="STS#1",
			[Switch]$TreeViewEnabled,
            [Switch]$AddToQuickLaunch,
            [Switch]$UseParentTopNav
		)

        begin {
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
        }

        process {
			if($global:ActivateTestLoggingVerbose){lm -message "Prüfe WebSite $Url" -category $($MyInvocation.MyCommand.Name)}
			$web = Get-SPWeb $Url -ErrorAction SilentlyContinue
			if($web -eq $null)
			{
				if($global:ActivateTestLoggingVerbose){lm -message "WebSite $Url existiert nicht und wird neu erstellt..." -category $($MyInvocation.MyCommand.Name)}
                $commandString = 'New-SPWeb -Url "' + $Url + '" -Template "' + $WebTemplate + '" -Name "' + $name + '"'
                if($AddToQuickLaunch)
                {
                    $commandString += ' -AddToQuickLaunch'
                }
                if($UseParentTopNav)
                {
                    $commandString += ' -UseParentTopNav'
                }
                Set-SPEVariable -VariableName newweb -CommandString $commandString
				if($treeViewEnabled)
				{
					$newweb.TreeViewEnabled = $true
				}
				$newweb.Update()
                $web = $newweb
                $newweb = $null
				if($global:ActivateTestLoggingVerbose){lm -message "...ZielWeb '$Url' wurde erstellt" -category $($MyInvocation.MyCommand.Name)}
			} else {
                if($global:ActivateTestLoggingVerbose){lm -message "ZielWeb '$Url' existiert bereits und wird verwendet." -category $($MyInvocation.MyCommand.Name)}
            }
            $web
            $web = $null
			return
		}
    }
	#endregion
    #EndOfFunction
		
	#region Function Remove-SPESPSubwebs
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
	function Remove-SPESPSubwebs
	{
        [CmdletBinding()]
        param
        ([Microsoft.SharePoint.SPWeb]$web)

        begin {
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
        }

        process {
			$WebUrl = $web.Url
			if($web.Webs.Count -gt 0)
			{
				if($global:ActivateTestLoggingVerbose){lm -message "Weitere SubWebSites vorhanden, iteriere tiefer...)" -category $($MyInvocation.MyCommand.Name)}
				foreach($subweb in $web.Webs)
				{
					Remove-SPESPSubwebs -web $subweb
				}
				if($global:ActivateTestLoggingVerbose){lm -message "...Alle SubWebSites auf dieser Ebene gelöscht" -category $($MyInvocation.MyCommand.Name)}
			}
			Remove-SPWeb $webUrl -Confirm:$false
			if($global:ActivateTestLoggingVerbose){lm -message "WebSite mit URL '$webUrl' gelöscht" -category $($MyInvocation.MyCommand.Name)}
		}
    }
	#endregion
    #EndOfFunction
	
	#region Function Copy-SPESPListViews
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
	function Copy-SPESPListViews
	{
        [CmdletBinding()]
        param
        (
		    [Microsoft.SharePoint.SPList]$sourceList,
		    [Microsoft.SharePoint.SPList]$targetList
	    )

        begin {
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
        }

        process {
			foreach($view in $sourceList.Views)
			{
				PauseOnKey
				$name = $view.title
				if($global:ActivateTestLoggingVerbose){lm -message "Kopiere View '$name'..." -category $($MyInvocation.MyCommand.Name)}
				$query = $view.Query
				$fieldsInternalNames = $view.ViewFields.ToStringCollection()
				#region Manipuliere FieldNamen
				$fieldsTitle = New-Object System.Collections.Specialized.StringCollection
				foreach($internalName in $fieldsInternalNames)
				{
					try
					{
						if($global:ActivateTestLoggingVerbose){lm -message "Erfasse Feld mit InternalName '$internalName'" -category $($MyInvocation.MyCommand.Name)}
						$field = $targetList.Fields.GetFieldByInternalName($internalName)
						if($global:ActivateTestLoggingVerbose){lm -message "...Feld konnte erfasst werden." -category $($MyInvocation.MyCommand.Name)}
						$fieldTitle = $internalName
						if($global:ActivateTestLoggingVerbose){lm -message "Füge Feld '$fieldTitle' hinzu." -category $($MyInvocation.MyCommand.Name)}
						$cache = $fieldsTitle.Add($fieldTitle)
					}
				    catch
				    {
                        if($global:ActivateTestLoggingException){
				            $exMessage = $_.Exception.Message
				            $innerException = $_.Exception.InnerException
						    $targetListTitle = $targetList.Title
				            $info = "Function: $($MyInvocation.MyCommand)" + "Fehler bei Kopieren von Views von Source-Liste '$sourceList' auf Target-Liste '$targetListTitle'."
						    if($innerException -match "does not exist. It may have been deleted by another user.")
						    {
							    #Feld existiert nicht
							    lm -message "Feld '$fieldTitle' existiert nicht auf Source-Liste '$sourceList'" -category $($MyInvocation.MyCommand.Name)
						    }
						    else
						    {
				                Push-SPEException -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -list $targetList -exMessage $exMessage -innerException $innerException -info $info
						    }
                        }
				    }
				}
				#endregion
				$isDefaultView = $view.DefaultView
				$paged = $view.paged
				$rowLimit = $view.RowLimit
				$type = $view.Type
				$personal = $view.PersonalView
					
				$newView = $targetList.Views.Add($name,$fieldsTitle,$query,$rowLimit,$paged,$isDefaultView,$type,$personal)
				$newView.Update()
				$targetList.Update()
				if($global:ActivateTestLoggingVerbose){lm -message "... Kopieren des Views '$name' erfolgreich abgeschlossen." -category $($MyInvocation.MyCommand.Name)}
			}
		}
    }
	#endregion
    #EndOfFunction
	
	#region Function Copy-SPESPFolderProperties
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
	function Copy-SPESPFolderProperties
	{
        [CmdletBinding()]
        param
        (
		    [Microsoft.SharePoint.SPFolder]$sourceFolder,
		    [Microsoft.SharePoint.SPFolder]$targetFolder
	    )

        begin {
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
        }

        process {
			Wait-SPEOnKey
			if($global:ActivateTestLoggingVerbose){lm -message "Übertrage Feldwerte..." -category $($MyInvocation.MyCommand.Name)}
			$sourceFields = $sourceFolder.Item.Fields | ?{!($_.sealed)}
			foreach($field in $sourceFields)
			{
				$fieldTitle = $field.Title
				try
				{
					if($global:ActivateTestLoggingVerbose){lm -message "...behandle Feld '$fieldTitle'..." -category $($MyInvocation.MyCommand.Name)}
					if($sourceFolder.Properties[$field.Title])
					{
						if($global:ActivateTestLoggingVerbose){lm -message "...Feld ist nicht leer..." -category $($MyInvocation.MyCommand.Name)}
						if(!($targetFolder.Properties[$field.Title]))
						{
							if($global:ActivateTestLoggingVerbose){lm -message "...Feld existiert nicht auf Zielordner und wird erstellt..." -category $($MyInvocation.MyCommand.Name)}
							$newPropCache = $targetFolder.AddProperty($field.Title, $sourceFolder.Properties[$field.Title])
							if($global:ActivateTestLoggingVerbose){lm -message "...Feld wurde erfolgreich erstellt..." -category $($MyInvocation.MyCommand.Name)}
						} else {
							if($global:ActivateTestLoggingVerbose){lm -message "...Feld existiert auf Zielordner und wird gefüllt..." -category $($MyInvocation.MyCommand.Name)}
							$targetFolder.Properties[$field.Title] = $sourceFolder.Properties[$field.Title]
							if($global:ActivateTestLoggingVerbose){lm -message "...Feld erfolgreich gefüllt..." -category $($MyInvocation.MyCommand.Name)}
						}
					} else {
						if($global:ActivateTestLoggingVerbose){lm -message "...Feld ist leer..." -category $($MyInvocation.MyCommand.Name)}
					}
				}
				catch
				{
                    if($global:ActivateTestLoggingException)
                    {
			            $exMessage = $_.Exception.Message
			            $innerException = $_.Exception.InnerException
					    if($exMessage -match "System.ArgumentException: Item has already been added. Key in dictionary")
                        {
				            $info = "Function: $($MyInvocation.MyCommand)" + "Wert für Feld '$fieldTitle' scheint schon gesetzt zu sein. Füre Update aus."
				            Push-SPEException -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -exMessage $exMessage -innerException $innerException -info $info
						    $targetFolder.Properties[$field.Title] = $sourceFolder.Properties[$field.Title]
					    } else {
			                $info = "Function: $($MyInvocation.MyCommand)" + "Fehler bei Übertrag des Feldwertes für Feld '$fieldTitle'"
			                Push-SPEException -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -exMessage $exMessage -innerException $innerException -info $info
					        Wait-SPEOnKey
					    }
                    }
				}
			}
		}
    }
	#endregion
    #EndOfFunction
		
	#region Function Copy-SPESPSubfolderItems
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
	function Copy-SPESPSubfolderItems
	{
        [CmdletBinding()]
        param
        (
	        [Microsoft.SharePoint.SPFolder]$sourceFolder,
	        [Microsoft.SharePoint.SPFolder]$targetFolder
        )

        begin {
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
        }

        process {
			$sourceFolderTitle = $sourceFolder.Name
			$targetFolderTitle = $targetFolder.Name
			if($global:ActivateTestLoggingVerbose){lm -message "Kopiere Dateien von Quellordner '$sourceFolderTitle' in Zielordner '$targetFolderTitle'" -category $($MyInvocation.MyCommand.Name)}
			$sourceWeb = $sourceFolder.ParentWeb
			$targetWeb = $targetFolder.ParentWeb
			$targetFolderFiles = $targetFolder.Files
			
			foreach($sourceFile in $sourceFolder.Files)
			{
				Wait-SPEOnKey
				$global:cntFiles++
				$fileSuccessfullyCopied = $false
				$sourceFileName = $sourceFile.Name
				try{
					if($global:ActivateTestLoggingVerbose){lm -message "'$global:cntFiles' - Kopiere Datei '$sourceFileName' in Zielordner '$targetFolderTitle'..." -category $($MyInvocation.MyCommand.Name)}
					$destUrl = $targetFolder.Url + "/" + $sourceFileName
					$binFile = $sourceFile.OpenBinary()
					$targetFile = $targetFolderFiles.Add($destUrl, $binFile, $true)
                    
					if($global:ActivateTestLoggingVerbose){lm -message "...Kopieren erfolgreich abgeschlossen." -category $($MyInvocation.MyCommand.Name)}
                    
					$fileSuccessfullyCopied = $true
                    
				}
				catch
				{
                    if($global:ActivateTestLoggingException)
                    {
		                $exMessage = $_.Exception.Message
		                $innerException = $_.Exception.InnerException
		                $info = "Function: $($MyInvocation.MyCommand)" + "Fehler bei Kopieren des Files '$sourceFileName'"
		                Push-SPEException -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -exMessage $exMessage -innerException $innerException -info $info
					    Wait-SPEOnKey
                    }
				}
				if($fileSuccessfullyCopied){
					lm -message "Übertrage Feldwerte..." -category $($MyInvocation.MyCommand.Name)
					$sourceFields = $sourceFile.Item.Fields | ?{!($_.sealed)}
					foreach($field in $sourceFields)
					{
						$fieldTitle = $field.Title
						try
						{
							lm -message "...behandle Feld '$fieldTitle'..." -category $($MyInvocation.MyCommand.Name)
							if($sourceFile.Properties[$field.Title])
							{
								if($global:ActivateTestLoggingVerbose){lm -message "...Feld ist nicht leer..." -category $($MyInvocation.MyCommand.Name)}
								if(!($targetFile.Properties[$field.Title]))
								{
									if($global:ActivateTestLoggingVerbose){lm -message "...Feld existiert nicht auf Zieldatei und wird erstellt..." -category $($MyInvocation.MyCommand.Name)}
									$newPropCache = $targetFile.AddProperty($field.Title, $sourceFile.Properties[$field.Title])
									if($global:ActivateTestLoggingVerbose){lm -message "...Feld wurde erfolgreich erstellt..." -category $($MyInvocation.MyCommand.Name)}
								} else {
									if($global:ActivateTestLoggingVerbose){lm -message "...Feld existiert auf Zieldatei und wird gefüllt..." -category $($MyInvocation.MyCommand.Name)}
									$targetFile.Properties[$field.Title] = $sourceFile.Properties[$field.Title]
									if($global:ActivateTestLoggingVerbose){lm -message "...Feld erfolgreich gefüllt..." -category $($MyInvocation.MyCommand.Name)}
								}
							} else {
								if($global:ActivateTestLoggingVerbose){lm -message "...Feld ist leer..." -category $($MyInvocation.MyCommand.Name)}
							}
						}
						catch
						{
                            if($global:ActivateTestLoggingException)
                            {
				                $exMessage = $_.Exception.Message
				                $innerException = $_.Exception.InnerException
				                $info = "Function: $($MyInvocation.MyCommand)" + "Fehler bei Übertrag des Feldwertes für Feld '$fieldTitle'"
				                Push-SPEException -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -exMessage $exMessage -innerException $innerException -info $info
							    Wait-SPEOnKey
                            }
						}
					}
					$targetFile.Update()
				} else {
					if($global:ActivateTestLoggingVerbose){lm -message "...Lfd.Nr '$global:cntFiles' - Fehler bei Kopieren der Datei '$sourceFileName' in Zielordner '$targetFolderTitle'" -category $($MyInvocation.MyCommand.Name)}
				}
			}
			$targetWeb = $null;
			$sourceWeb = $null;
		}
    }
	#endregion
    #EndOfFunction
		
	#region Function Copy-SPESPColumnDefaultValue
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
	function Copy-SPESPColumnDefaultValue
	{
        [CmdletBinding()]
        param
        (
			[Microsoft.SharePoint.SPFolder]$sourceFolder,
			[Microsoft.SharePoint.SPFolder]$targetFolder
		)

        begin {
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
        }

        process {
			Wait-SPEOnKey
			$sourceFolderTitle = $sourceFolder.Name
			$sourceListId = $sourceFolder.ParentListId
			$sourceList = $sourceFolder.ParentWeb.Lists[$sourceListId]
			$sourceWebLanguageId = $sourceFolder.ParentWeb.Language
			$sourceDefaultMetadata = New-Object Microsoft.Office.DocumentManagement.MetadataDefaults($sourceList)
			$sourceFolderMetadataDefault = $sourceDefaultMetadata.GetDefaultMetadata($sourceFolder)
			
			$targetFolderTitle = $targetFolder.Name
			$targetListId = $targetFolder.ParentListId
			$targetList = $targetFolder.ParentWeb.Lists[$targetListId]
			$targetWebLanguageId = $targetFolder.ParentWeb.Language
			$targetDefaultMetadata = New-Object Microsoft.Office.DocumentManagement.MetadataDefaults($targetList)
			$targetFolderMetadataDefault = $targetDefaultMetadata.GetDefaultMetadata($targetFolder)
			
			
			foreach($ColumnDefaultValuePair in $sourceFolderMetadataDefault)
			{
				$columnName = $ColumnDefaultValuePair.First
				$columnValue = $ColumnDefaultValuePair.Second
				if($global:ActivateTestLoggingVerbose){lm -message "Setze Column Default Value für Folder '$targetFolderTitle' in Spalte '$columnName' mit Wert '$columnValue'" -category $($MyInvocation.MyCommand.Name)}
				$targetDefaultMetadata.SetFieldDefault($targetFolder, $columnName, $columnValue)
				$targetDefaultMetadata.Update()
				$columnValueString = $columnValue.Split('#')[1].Split('|')[0]
				Wait-SPEOnKey
			}
		}
    }
	#endregion
    #EndOfFunction

	#region Function Export-SPESPSiteColumns
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
	function Export-SPESPSiteColumns
	{
        [CmdletBinding()]
        param
        (
			[String]$xmlFilePath,
			[Microsoft.SharePoint.SPWeb]$web,
			[String]$groupName
		)

        begin {
        }

        process {
			New-Item $xmlFilePath -type file -Force
			Add-Content $xmlFilePath "<?xml version=`"1.0`" encoding=`"utf-8`"?>"
			Add-Content $xmlFilePath "`n<Fields>"
			$web.Fields | ForEach-Object{
				if($_.Group -eq $groupName)
				{
					Add-Content $xmlFilePath $_.SchemaXml
				}
			}
			Add-Content $xmlFilePath "`n</Fields>"
		}
    }
	#endregion
    #EndOfFunction
		
	#region Function Import-SPESPSiteColumns
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
	function Import-SPESPSiteColumns
	{
        [CmdletBinding()]
        param
        (
		    [Microsoft.SharePoint.SPWeb]$web,
		    [String]$xmlFilePath
	    )

        begin {
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
        }

        process {
			$fieldNameList = New-Object system.Collections.ArrayList
			$fieldsXml = [xml](Get-Content($xmlFilePath))
			#region Collect FieldNames
			$fieldsXML.Fields.Field | ForEach-Object {
				$cache = $fieldNameList.Add($_.DisplayName)
			}
			#endregion
			#region Create Fields based on XML
			$fieldsXML.Fields.Field | ForEach-Object {
			
			    #region Configure core properties belonging to all column types
			    $fieldXML = '<Field Type="' + $_.Type + '"
			    Name="' + $_.Name + '"
			    ID="' + $_.ID + '"
			    Description="' + $_.Description + '"
			    DisplayName="' + $_.DisplayName + '"
			    StaticName="' + $_.StaticName + '"
			    Group="' + $_.Group + '"
			    Hidden="' + $_.Hidden + '"
			    Required="' + $_.Required + '"
			    Sealed="' + $_.Sealed + '"'
			    #endregion
				
			    #region Configure optional properties belonging to specific column types  you may need to add some extra properties here if present in your XML file
			    if ($_.ShowInDisplayForm) { $fieldXML = $fieldXML + "`n" + 'ShowInDisplayForm="' + $_.ShowInDisplayForm + '"'}
			    if ($_.ShowInEditForm) { $fieldXML = $fieldXML + "`n" + 'ShowInEditForm="' + $_.ShowInEditForm + '"'}
			    if ($_.ShowInListSettings) { $fieldXML = $fieldXML + "`n" + 'ShowInListSettings="' + $_.ShowInListSettings + '"'}
			    if ($_.ShowInNewForm) { $fieldXML = $fieldXML + "`n" + 'ShowInNewForm="' + $_.ShowInNewForm + '"'}
			        
			    if ($_.EnforceUniqueValues) { $fieldXML = $fieldXML + "`n" + 'EnforceUniqueValues="' + $_.EnforceUniqueValues + '"'}
			    if ($_.Indexed) { $fieldXML = $fieldXML + "`n" + 'Indexed="' + $_.Indexed + '"'}
			    if ($_.Format) { $fieldXML = $fieldXML + "`n" + 'Format="' + $_.Format + '"'}
			    if ($_.MaxLength) { $fieldXML = $fieldXML + "`n" + 'MaxLength="' + $_.MaxLength + '"' }
			    if ($_.FillInChoice) { $fieldXML = $fieldXML + "`n" + 'FillInChoice="' + $_.FillInChoice + '"' }
			    if ($_.NumLines) { $fieldXML = $fieldXML + "`n" + 'NumLines="' + $_.NumLines + '"' }
			    if ($_.RichText) { $fieldXML = $fieldXML + "`n" + 'RichText="' + $_.RichText + '"' }
			    if ($_.RichTextMode) { $fieldXML = $fieldXML + "`n" + 'RichTextMode="' + $_.RichTextMode + '"' }
			    if ($_.IsolateStyles) { $fieldXML = $fieldXML + "`n" + 'IsolateStyles="' + $_.IsolateStyles + '"' }
			    if ($_.AppendOnly) { $fieldXML = $fieldXML + "`n" + 'AppendOnly="' + $_.AppendOnly + '"' }
			    if ($_.Sortable) { $fieldXML = $fieldXML + "`n" + 'Sortable="' + $_.Sortable + '"' }
			    if ($_.RestrictedMode) { $fieldXML = $fieldXML + "`n" + 'RestrictedMode="' + $_.RestrictedMode + '"' }
			    if ($_.UnlimitedLengthInDocumentLibrary) { $fieldXML = $fieldXML + "`n" + 'UnlimitedLengthInDocumentLibrary="' + $_.UnlimitedLengthInDocumentLibrary + '"' }
			    if ($_.CanToggleHidden) { $fieldXML = $fieldXML + "`n" + 'CanToggleHidden="' + $_.CanToggleHidden + '"' }
			    if ($_.List) { $fieldXML = $fieldXML + "`n" + 'List="' + $_.List + '"' }
			    if ($_.ShowField) { $fieldXML = $fieldXML + "`n" + 'ShowField="' + $_.ShowField + '"' }
			    if ($_.UserSelectionMode) { $fieldXML = $fieldXML + "`n" + 'UserSelectionMode="' + $_.UserSelectionMode + '"' }
			    if ($_.UserSelectionScope) { $fieldXML = $fieldXML + "`n" + 'UserSelectionScope="' + $_.UserSelectionScope + '"' }
			    if ($_.BaseType) { $fieldXML = $fieldXML + "`n" + 'BaseType="' + $_.BaseType + '"' }
			    if ($_.Mult) { $fieldXML = $fieldXML + "`n" + 'Mult="' + $_.Mult + '"' }
			    if ($_.ReadOnly) { $fieldXML = $fieldXML + "`n" + 'ReadOnly="' + $_.ReadOnly + '"' }
			    if ($_.FieldRef) { $fieldXML = $fieldXML + "`n" + 'FieldRef="' + $_.FieldRef + '"' }    
			    $fieldXML = $fieldXML + ">"
				#endregion
			    
			    #region Create choices if choice column
			    if ($_.Type -eq "Choice") {
			        $fieldXML = $fieldXML + "`n<CHOICES>"
			        $_.Choices.Choice | ForEach-Object {
			            $fieldXML = $fieldXML + "`n<CHOICE>" + $_ + "</CHOICE>"
			        }
			        $fieldXML = $fieldXML + "`n</CHOICES>"
			    }
			    #endregion
				
			    #region Set Default value, if specified  
			    if ($_.Default) { $fieldXML = $fieldXML + "`n<Default>" + $_.Default + "</Default>" }
			    #endregion
				
			    #region End XML tag specified for this field
			    $fieldXML = $fieldXML + "</Field>"
			    #endregion
				
			    #region Create column on the site
				try{
			    $web.Fields.AddFieldAsXml($fieldXML.Replace("&","&amp;"))
			    if($global:ActivateTestLoggingVerbose){lm -message "Created site column $($_.DisplayName) on $($web.Url)" -category $($MyInvocation.MyCommand.Name)}
				}
		        catch
		        {
		            if($global:ActivateTestLoggingException)
                    {
                        $exMessage = $_.Exception.Message
		                $innerException = $_.Exception.InnerException
		                $info = "Function: $($MyInvocation.MyCommand)" + "Fehler bei Erstellen einer SiteColumn"
					    if(!($innerException -match "A duplicate field name"))
					    {
    			            Push-SPEException -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -web $web -exMessage $exMessage -innerException $innerException -info $info
	    				}
                    }
		        }
				#endregion
			}
			#endregion
			return $fieldNameList
		}
    }
	#endregion
    #EndOfFunction
				
	#region Function Add-SPESPSiteColumnToSPContentType
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
	function Add-SPESPSiteColumnToSPContentType
    {
        [CmdletBinding()]
        param
        (
	        [Microsoft.SharePoint.SPWeb]$web,
	        [String]$fieldName,
	        [String]$contentTypeName
        )

        begin {
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
        }

        process {
			#Get SiteColumn as Field from WebSite
			$field = $web.Fields[$fieldName]
			#Get ContentType from WebSite
			$ct = $web.ContentTypes[$contentTypeName]
			#Create FieldLink for Field/SiteColumn
			$link = New-Object Microsoft.SharePoint.SPFieldLink($field)
			#Add FieldLink to ContentType
			$ct.FieldLinks.Add($link)
			#Update ContentType
			$ct.Update($true)
		}
    }
	#endregion
    #EndOfFunction
		
	#region Function Add-SPESPContentTypesToSPList
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
	function Add-SPESPContentTypesToSPList
	{
        [CmdletBinding()]
        param
        (
		    [System.Collections.ArrayList]$contentTypeNames,
		    [Microsoft.SharePoint.SPWeb]$targetWeb,
		    [Microsoft.SharePoint.SPList]$newList
	    )

        begin {
        }

        process {
		    foreach($ctName in $contentTypeNames)
		    {
			    try
			    {
				    $ctToAdd = $targetWeb.Site.RootWeb.ContentTypes[$ctName]
				    if($ctToAdd -ne $null){
					    $listCTs = $newList.ContentTypes
					    $ctExists = $false
					    foreach($listCT in $listCTs)
					    {
						    if($listCT.Name -eq $ctToAdd.Name)
						    {
							    $ctExists = $true
								    break
						    }
					    }
					    if(!$ctExists){
						    $ct = $newList.ContentTypes.Add($ctToAdd)
						    $output = "ContentType '" + $ctName + "' wurde der Liste '" + $newList.Title + "' hinzugefügt."
					    } else {
						    $output = "ContentType '" + $ctName + "' existiert bereits auf der Liste '" + $newList.Title + "'."
					    }
					    $newList.Update()
				    } else {
					    $output = "ContentType '" + $ctName + "' konnte nicht gefunden werden."
				    }
				    if($global:ActivateTestLoggingVerbose){lm -message $output -category $($MyInvocation.MyCommand.Name)}
			    }
		        catch
		        {
		            if($global:ActivateTestLoggingException)
                    {
                        $exMessage = $_.Exception.Message
		                $innerException = $_.Exception.InnerException
		                $info = "Function: $($MyInvocation.MyCommand)" + "Fehler bei Behandlung des ContentTypes $ctName"
				        if(!($innerException -match "A duplicate field name"))
				        {
			                Push-SPEException -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -list $newList.Title -web $targetWeb.Title -exMessage $exMessage -innerException $innerException -info $info
				        }
                    }
		        }
		    }
	    }
    }
	#endregion
    #EndOfFunction
	
    #region Function Export-SPESPList
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    function Export-SPESPList
    {
        [CmdletBinding()]
	    Param (
		    [parameter(Mandatory=$true)]
            [string]$WebUrl, 
		    [parameter(Mandatory=$true)]
            [string]$ListName,
		    [parameter(Mandatory=$true)]
            [string]$Path,
		    [parameter(Mandatory=$false)]
            [switch]$ExcludeDependencies,
		    [parameter(Mandatory=$false)]
            [switch]$HaltOnWarning,
		    [parameter(Mandatory=$false)]
            [switch]$HaltOnNonfatalError,
		    [parameter(Mandatory=$false)]
            [switch]$AutoGenerateDataFileName,
		    [parameter(Mandatory=$false)]
            [switch]$TestRun,
		    [parameter(Mandatory=$false)]
            [ValidateSet("None","All","WssOnly")]
            [string]$IncludeSecurity="None",
		    [parameter(Mandatory=$false)]
            [ValidateSet("LastMajor","All","CurrentVersion","LastMajorAndMinor")]
            [string]$IncludeVersions="LastMajor",
		    [parameter(Mandatory=$false)]
            [int]$FileMaxSize=0,
		    [parameter(Mandatory=$false)]
            [switch]$Overwrite
	    )
        Begin{
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
		    #Load SharePoint 2010 cmdlets
		    $ver = $host | select version
		    if ($ver.Version.Major -gt 1)  {$Host.Runspace.ThreadOptions = "ReuseThread"}
		    Add-PsSnapin Microsoft.SharePoint.PowerShell -ErrorAction SilentlyContinue
		    #Load assemblies (needed for SharePoint Server 2007)
#		    [void][System.Reflection.Assembly]::LoadWithPartialName("Microsoft.SharePoint")
		
 		    $site = New-Object Microsoft.SharePoint.SPSite($WebUrl)
		    $web = $site.OpenWeb()
		    $list = $web.Lists[$ListName]
		    [bool]$FileCompression = $false
       }
        Process{
		    #Set file paths for the export file and logs
		    [string]$exportPath = $Path.TrimEnd("\")
		    if ($exportPath.EndsWith(".cmp")) 
		    { 
			    $FileCompression = $true
			    $exportFile = $Path.Replace($Path.Remove($Path.LastIndexOf("\")+1),"")
			    $exportPath = $Path.Remove($Path.LastIndexOf("\"))
		    }
            if($global:ActivateTestLoggingVerbose){lm -message "Export-File created at $exportPath" -category $($MyInvocation.MyCommand.Name)}
		    $exportObject = New-Object Microsoft.SharePoint.Deployment.SPExportObject
		    $exportObject.Id = $list.ID
		    $exportObject.Type = [Microsoft.SharePoint.Deployment.SPDeploymentObjectType]::Site
	
		    #Create the export settings from the parameters specified
		    $exportSettings = New-Object Microsoft.SharePoint.Deployment.SPExportSettings
		    $exportSettings.SiteUrl = $site.Url
		    $exportSettings.ExportMethod = [Microsoft.SharePoint.Deployment.SPExportMethodType]::ExportAll
		    $exportSettings.FileLocation = $exportPath 
		    $exportSettings.FileCompression = $FileCompression 
		    if ($FileCompression) { $exportSettings.BaseFileName = $exportFile }
		    $exportSettings.ExcludeDependencies = $ExcludeDependencies
		    $exportSettings.OverwriteExistingDataFile = $Overwrite
		    $exportSettings.IncludeSecurity = $IncludeSecurity
		    $exportSettings.IncludeVersions = $IncludeVersions
		    $exportSettings.LogFilePath = $logFilePath
		    $exportSettings.HaltOnWarning = $HaltOnWarning
		    $exportSettings.HaltOnNonfatalError = $HaltOnNonfatalError
		    $exportSettings.AutoGenerateDataFileName = $AutoGenerateDataFileName
		    $exportSettings.TestRun = $TestRun
		    $exportSettings.FileMaxSize = $FileMaxSize
		    $exportSettings.ExportObjects.Add($exportObject)
	
		    #Write the export settings to a log file    
		    $outSiteUrl = $site.Url
            if($global:ActivateTestLoggingVerbose){lm -message "SiteUrl = $outSiteUrl" -category $($MyInvocation.MyCommand.Name)}
            $outExportMethod = [Microsoft.SharePoint.Deployment.SPExportMethodType]::ExportAll
		    if($global:ActivateTestLoggingVerbose){lm -message "ExportMethod = $outExportMethod" -category $($MyInvocation.MyCommand.Name)}
		    if($global:ActivateTestLoggingVerbose){lm -message "FileLocation = $exportPath" -category $($MyInvocation.MyCommand.Name)}
		    if($global:ActivateTestLoggingVerbose){lm -message "FileCompression = $FileCompression" -category $($MyInvocation.MyCommand.Name)}
		    if ($FileCompression) { lm -message "BaseFileName = $exportFile" -category $($MyInvocation.MyCommand.Name) }
		    if($global:ActivateTestLoggingVerbose){lm -message "ExcludeDependencies = $ExcludeDependencies" -category $($MyInvocation.MyCommand.Name)}
		    if($global:ActivateTestLoggingVerbose){lm -message "OverwriteExistingDataFile = $Overwrite" -category $($MyInvocation.MyCommand.Name)}
		    if($global:ActivateTestLoggingVerbose){lm -message "IncludeSecurity = $IncludeSecurity" -category $($MyInvocation.MyCommand.Name)}
		    if($global:ActivateTestLoggingVerbose){lm -message "IncludeVersions = $IncludeVersions" -category $($MyInvocation.MyCommand.Name)}
		    if($global:ActivateTestLoggingVerbose){lm -message "LogFilePath = $logFilePath" -category $($MyInvocation.MyCommand.Name)}
		    if($global:ActivateTestLoggingVerbose){lm -message "HaltOnWarning = $HaltOnWarning" -category $($MyInvocation.MyCommand.Name)}
		    if($global:ActivateTestLoggingVerbose){lm -message "HaltOnNonfatalError = $HaltOnNonfatalError" -category $($MyInvocation.MyCommand.Name)}
		    if($global:ActivateTestLoggingVerbose){lm -message "AutoGenerateDataFileName = $AutoGenerateDataFileName" -category $($MyInvocation.MyCommand.Name)}
		    if($global:ActivateTestLoggingVerbose){lm -message "TestRun = $TestRun" -category $($MyInvocation.MyCommand.Name)}
		    if($global:ActivateTestLoggingVerbose){lm -message "FileMaxSize = $FileMaxSize" -category $($MyInvocation.MyCommand.Name)}
		    if($global:ActivateTestLoggingVerbose){lm -message "ExportObject = $exportObject" -category $($MyInvocation.MyCommand.Name)}
	
		    #Run the export procedure
		    $export = New-Object Microsoft.SharePoint.Deployment.SPExport($exportSettings)
		    # $exportSettings
		    # "Export läuft"
		    $export.Run()
		    if($global:ActivateTestLoggingVerbose){lm -message "Export fertig" -category $($MyInvocation.MyCommand.Name)}
		
        }
        End{
		    #Dispose of the web and site objects after use
		    $web = $null
		    $site = $null
        }
    }
    #endregion
    #EndOfFunction

    #region Function Test-SPESPContentTypeIsInNewButton
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    Function Test-SPESPContentTypeIsInNewButton {
        [CmdletBinding()]
        Param ([parameter(Mandatory=$true)][string] $ContentTypeName,
               [parameter(Mandatory=$true)][Microsoft.SharePoint.SPList] $SPList)
        BEGIN
        {
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
            if($global:ActivateTestLoggingVerbose){lm -message "Prüfe, ob ContentType $ContentTypeName am New-Button der Liste $($SPList.Title) hinterlegt ist..." -category $($MyInvocation.MyCommand.Name) }
        }
        PROCESS{
            #get the uniquecontenttypes from the list root folder
            $rootFolder = $SPList.RootFolder
            $contentTypesInPlace = [Microsoft.SharePoint.SPContentType[]] $rootFolder.UniqueContentTypeOrder
             
            #Check if any of them are the same as the test content type
            $results = $contentTypesInPlace | where { $_.Name -eq $ContentTypeName} 
            if ($results -ne $null)
            {
                if($global:ActivateTestLoggingVerbose){lm "$ContentTypeName ist am New-Button der Liste $($SPList.Title) hinterlegt." -category $($MyInvocation.MyCommand.Name)}
                return $true
            }
            else
            {
                if($global:ActivateTestLoggingVerbose){lm "$ContentTypeName ist nicht am New-Button der Liste $($SPList.Title) hinterlegt." -category $($MyInvocation.MyCommand.Name)}
                return $false
            }
        }
        END
        {
            if($global:ActivateTestLoggingVerbose){lm -message "Prüfung, ob ContentType $ContentTypeName am New-Button der Liste $($SPList.Title) hinterlegt ist, abgeschlossen." -category $($MyInvocation.MyCommand.Name)}
        }
    }
    #endregion 
    #EndOfFunction

    #region Function Test-SPESPContentTypeIsInSPEList
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    Function Test-SPESPContentTypeIsInSPEList{
        [CmdletBinding()]
        Param ( [parameter(Mandatory=$true,ValueFromPipeline=$true)][string] $ContentTypeName,
               [parameter(Mandatory=$true)][Microsoft.SharePoint.SPList] $SPList)
 
        BEGIN   {
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
            if($global:ActivateTestLoggingVerbose){lm -message "Stelle sicher, ob ContentType(s) von Liste $($SPList.Title) referenziert wird/werden..." -category $($MyInvocation.MyCommand.Name) }
        }
        PROCESS { 
 
             #Check to see if the content type is already in the list
             $contentType = $SPList.ContentTypes[$ContentTypeName]
             if ($ContentType -ne $null)
             {
                #Content type already present
                if($global:ActivateTestLoggingVerbose){lm -message "ContentType $ContentTypeName wird bereits von Liste $($SPList.Title) referenziert." -category $($MyInvocation.MyCommand.Name)}
                Return $true
             }
             else
             {
                if($global:ActivateTestLoggingVerbose){lm -message "ContentType $ContentTypeName wird nicht von Liste $($SPList.Title). Füge ContentType hinzu..." -category $($MyInvocation.MyCommand.Name)}
                if (!$SPList.ContentTypesEnabled)
                {
                    if($global:ActivateTestLoggingVerbose){lm -message "Die Nutzung von ContentTypes in Liste $($SPList.Title) ist deaktiviert. Aktiviere..." -category $($MyInvocation.MyCommand.Name)}
                    $SPList.ContentTypesEnabled = $true
                    $SPList.Update()
                }
                 #Add site content types to the list from the site collection root
                 $ctToAdd = $SPList.ParentWeb.Site.RootWeb.ContentTypes[$ContentTypeName]
                 if($ctToAdd -eq $null)
                 {
                    if($global:ActivateTestLoggingVerbose){lm -message "ContentType $ContentTypeName konnte nicht in der übergeordneten SiteCollection gefunden werden." -category $($MyInvocation.MyCommand.Name)}
                    #I don't believe this will be called.
                    return $false
                 }
                 $SPList.ContentTypes.Add($ctToAdd) | Out-Null
                 $SPList.Update()
                 if($global:ActivateTestLoggingVerbose){lm -message "ContentType $ContentTypeName wurde der Liste $($SPList.Title) hinzugefügt." -category $($MyInvocation.MyCommand.Name)}
                 return $true
             }
            }
        END 
        {
            if($global:ActivateTestLoggingVerbose){lm -message "Sicherstellen, ob ContentType(s) von Liste $($SPList.Title) referenziert wird/werden, abgeschlossen." -category $($MyInvocation.MyCommand.Name)}
        }
    }
    #endregion 
    #EndOfFunction

    #region Function Set-SPESPContentTypeInNewButton
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    Function Set-SPESPContentTypeInNewButton{
    [CmdletBinding()]
    Param ( [parameter(Mandatory=$true,ValueFromPipeline=$true)][string] $ContentTypeName,
            [parameter(Mandatory=$true)][Microsoft.SharePoint.SPList] $SPList)
        BEGIN   { 
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
            if($global:ActivateTestLoggingVerbose){lm -message "Stelle sicher, ob ContentType(s) am New-Button der Liste $($SPList.Title) hinterlegt ist." -category $($MyInvocation.MyCommand.Name)}
            #get the uniquecontenttypes from the list root folder
            $contentTypesInPlace = New-Object 'System.Collections.Generic.List[Microsoft.SharePoint.SPContentType]'
            $contentTypesInPlace = $SPList.RootFolder.UniqueContentTypeOrder
            $dirtyFlag = $false
                }
        PROCESS { 
                 
            #Check the content type isn't already present in the content type
            $AlreadyPresent = Test-SPESPContentTypeIsInNewButton -ContentTypeName $ContentTypeName -SPList $SPList
            if ($AlreadyPresent)
            {
                if($global:ActivateTestLoggingVerbose){lm -message "ContentType $ContentTypeName ist bereits am New-Button der Liste $($SPList.Title) hinterlegt." -category $($MyInvocation.MyCommand.Name)}
            }
            else
            {
                #Check that there really is such a content type
                $ContentTypePresent = Test-SPESPContentTypeIsInSPEList $ContentTypeName $SPList
                #Catch error events
                if ($ContentTypePresent)
                {
                    #We now know that the content type is not in the new button and is present in the list. Carry on adding the content type
                 
                    $ctToAdd = $SPList.ContentTypes[$ContentTypeName]
                 
                    #add our content type to the unique content type list
                    $contentTypesInPlace  =  $contentTypesInPlace + $ctToAdd
                    $dirtyFlag = $true
                    if($global:ActivateTestLoggingVerbose){lm -message "ContentType $ContentTypeName wurde der Liste der hinzuzufügenden ContentTypes hinzugefügt." -category $($MyInvocation.MyCommand.Name)}
                }
                else
                {
                    if($global:ActivateTestLoggingVerbose){lm -message "ContentType $ContentTypeName konnte nicht hinzugefügt werden." -category $($MyInvocation.MyCommand.Name)}
                }
            }
        }
        End{
            #Set the UniqueContentTypeOrder to the collection we made above
            if ($dirtyFlag)
            {
               $SPList = $SPList.ParentWeb.Lists[$SPList.ID]
                $rootFolder = $SPList.RootFolder
                $rootFolder.UniqueContentTypeOrder = [Microsoft.SharePoint.SPContentType[]]  $contentTypesInPlace
         
                 #Update the root folder
                 $rootFolder.Update()
                 if($global:ActivateTestLoggingVerbose){lm -message "ContentType(s) wurde(n) dem New-button der Liste $($SPList.Title) hinzugefügt" -category $($MyInvocation.MyCommand.Name)}
            }
            else
            {
                    if($global:ActivateTestLoggingVerbose){Write-SPELogAndTextMessage -message "No changes" -category $($MyInvocation.MyCommand.Name)}
            }
            if($global:ActivateTestLoggingVerbose){lm -message "sicherstellen von ContentType(s) am New-Button der Liste $($SPList.Title) abgeschlossen." -category $($MyInvocation.MyCommand.Name)}
        }
    }
    #endregion 
    #EndOfFunction

    #region Function Remove-SPESPContentTypeFromNewButton
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    Function Remove-SPESPContentTypeFromNewButton{
   [CmdletBinding()]
    Param ( [parameter(Mandatory=$true,ValueFromPipeline=$true)][string] $ContentTypeName,
            [parameter(Mandatory=$true)][Microsoft.SharePoint.SPList] $SPList)
     
    BEGIN   {
        $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
        if($global:ActivateTestLoggingVerbose){lm -message "Entferne ContentType(s) vom New-Button der Liste $($SPList.Title)..." -category $($MyInvocation.MyCommand.Name)}
    }
    PROCESS { 
    
                #Check the content type isn't already present in the content type
                $AlreadyPresent = Test-SPESPContentTypeIsInNewButton -ContentTypeName $ContentTypeName -SPList $SPList
                if ($AlreadyPresent)
                {
                    if($global:ActivateTestLoggingVerbose){lm -message "ContentType $ContentTypeName existiert am New-Button der Liste $($SPList.Title) und wird gelöscht..." -category $($MyInvocation.MyCommand.Name)}
                    #get the uniquecontenttypes from the list root folder
                    $rootFolder = $SPList.RootFolder
                 
                    #Get the content types where the names are different to our content type
                    $contentTypesInPlace = [System.Collections.ArrayList] $rootFolder.UniqueContentTypeOrder
                    $contentTypesInPlace = $contentTypesInPlace | where {$_.Name -ne $contentTypeName}
                 
                    #Set the UniqueContentTypeOrder to the collection we made above
                    $rootFolder.UniqueContentTypeOrder = [Microsoft.SharePoint.SPContentType[]]  $contentTypesInPlace
                 
                    #Update the root folder
                    $rootFolder.Update()
                    if($global:ActivateTestLoggingVerbose){lm -message "ContentType $ContentTypeName wurde vom New-Button der Liste $($SPList.Title) gelöscht." -category $($MyInvocation.MyCommand.Name)}
                }
                else
                {
                    if($global:ActivateTestLoggingVerbose){lm -message "ContentType $ContentTypeName existiert nicht am New-Button der Liste $($SPList.Title)." -category $($MyInvocation.MyCommand.Name)}
                }
            }
    END     {if($global:ActivateTestLoggingVerbose){lm -message "Entfernen von ContentType(s) vom New-Button der Liste $($SPList.Title) abgeschlossen." -category $($MyInvocation.MyCommand.Name)}}
 
    }
    #endregion 
    #EndOfFunction

    #region Function Remove-SPESPListView
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    function Remove-SPESPListView {
        [CmdletBinding()]
        Param(
            [Microsoft.SharePoint.SPList]$SPList,
            [string]$ViewName
        )
        Begin{}
        Process{
            $View = $List.Views[$ViewName]
            $List.Views.Delete($View.ID)
            $List.Update()
        }
        }
    #endregion
    #EndOfFunction

#endregion

#region Functions for SharePoint Online

    #region Function Get-SPESPOnlineCredentials
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    Function Get-SPESPOnlineCredentials
    {
        [CmdletBinding()]
        param
        (
        )

        begin 
        {
            Test-SPEAndLoadCsomDLLs
        }
        process
        {
            $Credential = Get-SPECredentialsFromCurrentUser -SPO
            $SPOCred = New-Object Microsoft.SharePoint.Client.SharePointOnlineCredentials($Credential.UserName, $Credential.Password)
            return $SPOCred
        }

    }
    #endregion
    #EndOfFunction

    #region Function Get-SPESPOnlineContext
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    function Get-SPESPOnlineContext {
        [CmdletBinding()]
        param
        (
 		    [Parameter(Position=0, Mandatory=$true)]
		    [ValidateNotNullOrEmpty()]
		    [System.String]
		    $Url,
		    [Parameter(Position=1)]
		    [ValidateNotNull()]
		    [Microsoft.SharePoint.Client.SharePointOnlineCredentials]
		    $Credentials,
            [Parameter(Position=2)]
            [Switch]$AsGlobal
       )

        begin 
        {
            Test-SPEAndLoadCsomDLLs
        }

        process 
        {
            if(!$Credentials -and !$global:cred)
            {
                $global:cred = Get-SPESPOnlineCredentials
                $Credentials = $cred
            }
            $ctx = New-Object Microsoft.SharePoint.Client.ClientContext($url)
            $ctx.Credentials = $Credentials

            if(!$ctx.ServerObjectIsNull.Value)
            {
                if($AsGlobal)
                {
                    $global:ctx = $ctx
                }
                return $ctx
            }
            else
            {
                return $null
            }
        }
    }
    #endregion
    #EndOfFunction
        
    #region Function Get-SPESPOnlineWeb
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    function Get-SPESPOnlineWeb {
        [CmdletBinding(DefaultParameterSetName="ByUrl")]
        param
        (
 		    [Parameter(Position=0, Mandatory=$true,ParameterSetName="ByUrl")]
		    [ValidateNotNullOrEmpty()]
		    [System.String]
		    $Url,
 		    [Parameter(Position=0, Mandatory=$true,ParameterSetName="ByContext")]
		    [ValidateNotNullOrEmpty()]
            [Microsoft.Sharepoint.Client.ClientContext]
            $Context,
		    [Parameter(Position=1)]
		    [Microsoft.SharePoint.Client.SharePointOnlineCredentials]
		    $Credentials
       )

        begin 
        {
            Test-SPEAndLoadCsomDLLs
        }

        process 
        {
            switch($PSCmdlet.ParameterSetName)
            {
                "ByUrl"{
                    $ctx = Get-SPESPOnlineContext -Url $url -Credentials $Credentials
                    if($ctx)
                    {
                        $web = $ctx.Web
                        $ctx.Load($web)
                        $ctx.ExecuteQuery()
                        return $web
                    }
                    else
                    {
                        return $null
                    }
                }
                "ByContext"{
                    $web = $ctx.Web
                    $ctx.Load($web)
                    $ctx.ExecuteQuery()
                    return $web
                }
            }
        }
    }
    #endregion
    #EndOfFunction

    #region Function Get-SPESPOnlineObjectByCtx
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    function Get-SPESPOnlineObjectByCtx {
        [CmdletBinding()]
        param
        (
            [Parameter(Position=0,Mandatory=$true)]
            [ValidateNotNullOrEmpty()]
            [PSObject]$ParentObject,
            [Parameter(Position=1,Mandatory=$false)]
            [ValidateNotNullOrEmpty()]
            $ChildObject,
            [Parameter(Position=2,Mandatory=$false)]
            [Microsoft.SharePoint.Client.ClientContext]$Ctx=$global:ctx
        )

        begin 
        {
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
            Test-SPEAndLoadCsomDLLs
        }

        process 
        {
            try
            {
                $objToLoad = $ParentObject.($ChildObject)
                $ctx.Load($objToLoad)
                $ctx.ExecuteQuery()
                return $objToLoad
            }
            catch
            {
                if($global:ActivateTestLoggingException)
                {
                    $exMessage = $_.Exception.Message
                    $innerException = $_.Exception.InnerException
                    $info = "Function: $($MyInvocation.MyCommand)" + "Fehler bei Erfassen des ChildObjects '$ChildObject'"
                    Push-SPEException -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -exMessage $exMessage -innerException $innerException -info $info
                }
                return $null
            }
        }
    }
    #endregion
    #EndOfFunction

    #region Function Get-SPESPOnlineSubWebs
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    Function Get-SPESPOnlineSubWebs
    {
        [CmdletBinding()]
        param
        (
            [Parameter(Position=0,Mandatory=$true)]
            [ValidateNotNullOrEmpty()]
            [Microsoft.SharePoint.Client.Web]$web,
            [Parameter(Position=1,Mandatory=$false)]
            [Microsoft.SharePoint.Client.ClientContext]$Ctx=$global:ctx
        )
        Begin{
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
            Test-SPEAndLoadCsomDLLs
        }
        Process
        {
            try
            {
                if($global:ActivateTestLoggingVerbose){lm -message "Erfasse SubWebs von Website '$($web.title)'..." -category $($MyInvocation.MyCommand.Name)}
                $subwebs = Get-SPESPOnlineObjectByCtx -ParentObject $web -ChildObject "Webs"
                if($global:ActivateTestLoggingVerbose){lm -message "Es wurden $($subwebs.Count) SubWebs von Website '$($web.title)' erfasst." -category $($MyInvocation.MyCommand.Name)}
                return $subwebs
            }
            catch 
            {
                if($global:ActivateTestLoggingException)
                {
                    $exMessage = $_.Exception.Message
                    $innerException = $_.Exception.InnerException
                    $info = "Function: $($MyInvocation.MyCommand)" + "Fehler bei Erfassen der SubWebs von Website '$($web.title)'"
                    Push-SPEException -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -exMessage $exMessage -innerException $innerException -info $info
                }
                return $null
            }
        }
    }
    #endregion
    #EndOfFunction
    
    #region Function Get-SPESPOnlineSubWebsIterative
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    Function Get-SPESPOnlineSubWebsIterative
    {
        [CmdletBinding()]
        param
        (
            [Parameter(Position=0,Mandatory=$true)]
            [ValidateNotNullOrEmpty()]
            [Microsoft.SharePoint.Client.Web]$web,
            [Parameter(Position=1,Mandatory=$false)]
            [Array]$properties,
            [Parameter(Position=2,Mandatory=$false)]
            [Microsoft.SharePoint.Client.ClientContext]$Ctx=$global:ctx

        )
        Begin{
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
            Test-SPEAndLoadCsomDLLs
        }
        Process
        {
            if($global:ActivateTestLogging){lm -message "Erfassung aller SubWebs von Website '$($web.title)' mit URL '$($web.Url)'..." -category $($MyInvocation.MyCommand.Name)}
            $collectedSubWebs = New-Object System.Collections.ArrayList
            if($global:ActivateTestLoggingVerbose){Write-SPELogAndTextMessage -message "aktueller Zähler collectedSubWebs: $($collectedSubWebs.Count)" -category $($MyInvocation.MyCommand.Name)}

            $subwebs = Get-SPESPOnlineSubWebs -web $web
            if($global:ActivateTestLoggingVerbose){Write-SPELogAndTextMessage -message "Es wurden $($subwebs.Count) SubWebs erfasst." -category $($MyInvocation.MyCommand.Name)}
            if($subwebs.Count -gt 0)
            {
                foreach($subweb in $subwebs)
                {
                    if(!$properties)
                    {
                        # Hole pauschal alle Properties des Web-Objects, die durch Get-SPECSOMProperties verarbeitet werden können.
                        $properties = $subweb | 
                            gm -force | 
                            ?{
                                $_.MemberType -eq "Property" -and 
                                $_.Name -ne "Context" -and 
                                $_.Name -ne "ObjectVersion" -and 
                                $_.Name -ne "Path" -and
                                $_.Name -ne "ServerObjectIsNull" -and
                                $_.Name -ne "Tag" -and
                                $_.Name -ne "TypedObject"
                            } | 
                            select name | 
                            %{$_.Name.ToString()}
                    }
                    $deeperSubWebs = Get-SPESPOnlineSubWebsIterative -web $subweb -properties $properties

                    #Get-SPECSOMProperties -object $subweb -propertyNames $properties -executeQuery
                    $collectedSubWebs.add($htweb) | out-null
                 }
            }
                   
            if($global:ActivateTestLogging){Write-SPELogAndTextMessage -message "Anzahl CollectedSubWebs: $($collectedSubWebs.Count)" -category $($MyInvocation.MyCommand.Name)}


            if($global:ActivateTestLogging){lm -message "Erfassung aller Subwebs von Website '$($web.title)' abgeschlossen." -category $($MyInvocation.MyCommand.Name)}
            return $collectedSubWebs
        }
    }
    #endregion
    #EndOfFunction

    #region Function Get-SPEObjectFromSPOnlineObject
    #.ExternalHelp SPE.SharePoint.psm1-help.xml
    Function Get-SPEObjectFromSPOnlineObject
    {
        [CmdletBinding()]
        param(
            [Parameter(Position=0,Mandatory=$false)]
            [Microsoft.SharePoint.Client.ClientContext]
            $Ctx,
            [Parameter(Position=1)]
            [ValidateNotNullOrEmpty()]
            $object,
            [Parameter(Position=2)]
            [String]
            $PropertyName,
            [Parameter(Position=3)]
            [Array]
            $PriorObjects,
            [Parameter(Position=4)]
            [int]
            $Level,
            [Parameter(Position=5)]
            [int]
            $CollectionCount,
            [Parameter(Position=6)]
            [int]
            $CollectionCurrent

        )
        Begin
        {
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
            Test-SPEAndLoadCsomDLLs
        }
        Process
        {
#            $textArray = @()
#            if($CollectionCount -and $CollectionCurrent)
#            {
#                $textArray += @(
#                    "CollectionItems : $CollectionCount",
#                    "Akt. Item Nr.   : $CollectionCurrent",
#                    ""
#                )
#            }
#            $textArray += @(
#                "Iterationstiefe : $Level",
#                "",
#                "PropertyName    : $PropertyName",
#                "",
#                "PriorObjects    :")
#            foreach($pObj in $PriorObjects)
#            {
#                $textArray += $pObj
#            }
            #Show-SPETextArray -textArray $textArray
#            $textMessage = ""
#            foreach($textString in $textArray)
#            {
#                $textMessage += $textString
#            }
            #lm -message $textMessage
            $Level++

            #region Parameter für Logging
            $curCorrId = $global:CorrelationId
            $fctCorrId = Set-SPEGuidIncrement4thBlock -guid $curCorrId
            #endregion
            if($PriorObjects -is [Array] -and !([String]::IsNullOrEmpty($PropertyName))) # -and $PriorObjects.Contains($PropertyName))
            {
                foreach($priorObject in $PriorObjects)
                {
                    $POName = $priorObject.Split(" - ")[0]
                    if($POName -eq $PropertyName)
                    {
                        return $null
                    }
                }
            } 
#            else 
#            {
                if(!($PriorObjects -is [Array]))
                {
                    $PriorObjects = @()
                    $PriorObjects = Get-SPEBaseTypeNameFromObject -object $object
                } else {
                    $PriorObjects += "$PropertyName - $CollectionCount - $CollectionCurrent"
                }
                $speObject = New-Object PsObject
                if((Get-SPEBaseTypeNameFromObject -object $object) -eq "Web")
                {
                    $speObject | Add-Member -MemberType NoteProperty -Name Context -Value $Ctx
                }

                #region Erfasse alle Properties
                $Properties = $object | gm -force | ?{$_.MemberType -eq "Property"} | ?{$_.Name.ToString() -ne ""} | select Name, Definition
                #endregion
                
                #region Erfasse Values der NON-SPC-Properties
                foreach($PropertyItem in $Properties)
                {
                    $fctCorrId = Set-SPEGuidIncrement4thBlock -guid $fctCorrId
  
                    $Property = $PropertyItem.Name.ToString()
                    $Definition = $PropertyItem.Definition.ToString()
                    if($Property -ne "TypedObject")
                    {
                        if($Definition.StartsWith("Microsoft.SharePoint.Client"))
                        {
                            try
                            {
                                $isComplexObject = $true
                                $childObject = Get-SPESPOnlineObjectByCtx -ParentObject $object -ChildObject $Property
                                if($childObject)
                                {
                                    if($Definition.Contains("Collection"))
                                    {
                                        $CurCollectionCount = $childObject.Count
                                        $collection = @()
                                        $collCnt = 0
                                        foreach($CollectionItem in $childObject)
                                        {
#                                            if($global:ActivateTestLoggingVerbose){lm -message "Schreibe SPC-Object '$Property'..." -level Verbose -CorrelationId $fctCorrId  -eventId $eventid -process $Property}
                                            $ChildObjects = Get-SPEObjectFromSPOnlineObject -object $childObject[$collCnt] -Ctx $Ctx -PropertyName $Property -PriorObjects $PriorObjects -Level $Level -CollectionCount $CurCollectionCount -CollectionCurrent $collCnt
                                            $collection += $ChildObjects
                                            $collCnt++
                                        }
                                        $speObject | Add-Member  -MemberType NoteProperty -Name $Property -Value $collection
                                        $collection.Clear()
                                    }
                                    else
                                    {
#                                        if($global:ActivateTestLoggingVerbose){lm -message "Schreibe SPC-Object '$Property'..." -level Verbose -CorrelationId $fctCorrId  -eventId $eventid -process $Property}
                                        $ChildObjects = Get-SPEObjectFromSPOnlineObject -object $childObject -Ctx $Ctx -PropertyName $Property -PriorObjects $PriorObjects -Level $Level
                                        $speObject | Add-Member  -MemberType NoteProperty -Name $Property -Value $ChildObjects
                                    }
                                }
                            }
                            catch
                            {
                                $isComplexObject = $false
                                #vielleicht doch ein Simple Object?
#                                if($global:ActivateTestLoggingException)
#                                {
#                                    $exMessage = $_.Exception.Message
#                                    $innerException = $_.Exception.InnerException
#                                    $info = "Function: $($MyInvocation.MyCommand)" + "Fehler bei Erfassen des Property-Object '$Property_SPC'"
#                                    #Push-SPEException -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -exMessage $exMessage -innerException $innerException -info $info
#                                }
                            }
                            if($isComplexObject)
                            {
                                if($global:ActivateTestLoggingVerbose){lm -message "...Schreiben von SPC-Object '$Property' erfolgreich abgeschlossen." -level Verbose -CorrelationId $fctCorrId  -eventId $eventid -process $Property -category $($MyInvocation.MyCommand.Name)}
                            }
                            else
                            {
                                try
                                {
#                                    if($global:ActivateTestLoggingVerbose){lm -message "SPC-Object '$Property' konnte nicht als Object erfasst werden. Versuche als SimpleObject zu erfassen..." -level High -CorrelationId $fctCorrId  -eventId $eventid -process $Property}
                                    $isSimpleObject = $true
                                    $speObject | Add-Member -Name $Property -Value $($object.($Property)) -MemberType NoteProperty
                                }
                                catch
                                {
                                    $isSimpleObject = $false
#                                    if($global:ActivateTestLoggingException)
#                                    {
#                                        $exMessage = $_.Exception.Message
#                                        $innerException = $_.Exception.InnerException
#                                        $info = "Function: $($MyInvocation.MyCommand)" + "Fehler bei nachträglichem Erfassen des Property-Object '$Property' als SimpleObject"
#                                        #Push-SPEException -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -exMessage $exMessage -innerException $innerException -info $info
#                                    }
                                }
#                                if($isSimpleObject)
#                                {
#                                    if($global:ActivateTestLoggingVerbose){lm -message "...SPQ-Object '$Property' konnte als SimpleObject erfasst werden." -level Verbose -CorrelationId $fctCorrId  -eventId $eventid -process $Property}
#                                } 
#                                else
#                                {
#                                    if($global:ActivateTestLoggingVerbose){lm -message "...SPQ-Object '$Property' konnte nicht erfasst werden." -level High -CorrelationId $fctCorrId  -eventId $eventid -process $Property}
#                                }
                    
                            }
                        }
                        else
                        {
                            try
                            {
#                                if($global:ActivateTestLoggingVerbose){lm -message "Schreibe NON-SPC-Property '$Property'..." -CorrelationId $fctCorrId -eventId $eventid -process $Property}
                                $speObject | Add-Member -Name $Property -Value $($object.($Property)) -MemberType NoteProperty -force
#                                if($global:ActivateTestLoggingVerbose){lm -message "...Schreiben von NON-SPC-Property '$Property' abgeschlossen." -CorrelationId $fctCorrId -eventId $eventid -process $Property}
                            }
                            catch
                            {
#                                if($global:ActivateTestLoggingException)
#                                {
#                                    $exMessage = $_.Exception.Message
#                                    $innerException = $_.Exception.InnerException
#                                    $info = "Function: $($MyInvocation.MyCommand)" + "Fehler bei direktem Erfassen des Property-Values '$Property' als SimpleObject"
#                                    Push-SPEException -Category "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)" -exMessage $exMessage -innerException $innerException -info $info
#                                }
                            }
                        }
                    }
                }
                #endregion
                
                return $speObject
 #           }
        }
    }
    #endregion
    #EndOfFunction

    #region Function Get-SPESPOnlineLists
    Function Get-SPESPOnlineLists
    {
        [CmdletBinding()]
        param(
            [Parameter(
                Position=0, 
                Mandatory=$true , 
                ValueFromPipeline=$True, 
                ValueFromPipelinebyPropertyName=$True
            )]
            [Microsoft.SharePoint.Client.Web]
            $Web
        )
        Begin{
            $LogCat = "$($MyInvocation.MyCommand.ModuleName)_$($MyInvocation.MyCommand.Name)"
            Test-SPEAndLoadCsomDLLs
            $collectedLists = New-Object psobjectject
        }
        Process{
#            foreach($item in $web)
#            {
                $lists = Get-SPESPOnlineObjectByCtx -ParentObject $web -ChildObject "Lists"
                #return $lists
                foreach($list in $lists){
#                    $catchOut = $collectedLists.Add($list)
                    $collectedLists | Add-Member -MemberType NoteProperty -Name $($list.Title) -Value $list 
                }
#            }
        }
        End{
            return $collectedLists
        }
    }
    #endregion
    #EndOfFunction

#endregion

#region vars
$Global:SPE_ListTempateIDsToNames = @{    
    100 = "Generic list";
    101 = "Document library";
    102 = "Survey";
    103 = "Links list";
    104 = "Announcements list";
    105 = "Contacts list";
    106 = "Events list";
    107 = "Tasks list";
    108 = "Discussion board";
    109 = "Picture library";
    110 = "Data sources";
    111 = "Site template gallery";
    112 = "User Information list";
    113 = "Web Part gallery";
    114 = "List template gallery";
    115 = "XML Form library";
    116 = " Master pages gallery";
    117 = "No-Code Workflows";
    118 = "Custom Workflow Process";
    119 = "Wiki Page library";
    120 = "Custom grid for a list";
    130 = "Data Connection library";
    140 = "Workflow History";
    150 = "Gantt Tasks list";
    200 = "Meeting Series list";
    201 = "Meeting Agenda list";
    202 = "Meeting Attendees list";
    204 = "Meeting Decisions list";
    207 = "Meeting Objectives list";
    210 = "Meeting text box";
    211 = "Meeting Things To Bring list";
    212 = "Meeting Workspace Pages list";
    301 = "Blog Posts list";
    302 = "Blog Comments list";
    303 = "Blog Categories list";
    433 = "Report Library";
    851 = "Asset Library";
    1100 = "Issue tracking";
    1200 = "Administrator tasks list";
}
$Global:SPE_ListTempateNamesToIDs = @{    
    "Generic list" = 100;
    "Document library" = 101;
    "Survey" = 102;
    "Links list" = 103;
    "Announcements list" = 104;
    "Contacts list" = 105;
    "Events list" = 106;
    "Tasks list" = 107;
    "Discussion board" = 108;
    "Picture library" = 109;
    "Data sources" = 110;
    "Site template gallery" = 111;
    "User Information list" = 112;
    "Web Part gallery" = 113;
    "List template gallery" = 114;
    "XML Form library" = 115;
    " Master pages gallery" = 116;
    "No-Code Workflows" = 117;
    "Custom Workflow Process" = 118;
    "Wiki Page library" = 119;
    "Custom grid for a list" = 120;
    "Data Connection library" = 130;
    "Workflow History" = 140;
    "Gantt Tasks list" = 150;
    "Meeting Series list" = 200;
    "Meeting Agenda list" = 201;
    "Meeting Attendees list" = 202;
    "Meeting Decisions list" = 204;
    "Meeting Objectives list" = 207;
    "Meeting text box" = 210;
    "Meeting Things To Bring list" = 211;
    "Meeting Workspace Pages list" = 212;
    "Blog Posts list" = 301;
    "Blog Comments list" = 302;
    "Blog Categories list" = 303;
    "Report Library" = 433;
    "Asset Library" = 851;
    "Issue tracking" = 1100;
    "Administrator tasks list" = 1200;
}
$Global:SPE_ListFieldTypes = @{
    1 = "Integer";
    2 = "Text";
    3 = "Note";
    4 = "DateTime";
    5 = "Counter";
    6 = "Choice";
    7 = "Lookup";
    8 = "Boolean";
    9 = "Number";
    10 = "Currency";
    11 = "URL";
    12 = "Computed";
    13 = "Threading";
    14 = "Guid";
    15 = "MultiChoice";
    16 = "GridChoice";
    17 = "Calculated";
    18 = "File";
    19 = "Attachments";
    20 = "User";
    21 = "Recurrence";
    22 = "CrossProjectLink";
    23 = "ModStat";
    24 = "Error";
    25 = "ContentTypeId";
    26 = "PageSeparator";
    27 = "ThreadIndex";
    28 = "WorkflowStatus";
    29 = "AllDayEvent";
    30 = "WorkflowEventType";
}
#endregion

#endregion 

export-modulemember -alias * -function *

#EndOfFile