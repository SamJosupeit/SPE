#region Script-Header with Description and Versioning
<######################################################################
# MT AG - 40882 Ratingen                                              #
# Powershell-Script                                                   #
# #####################################################################
# Name:        SamsPowerShellEnhancements.psm1                        #
# Description: This PowerShell-Module contains functions to be used   #
#              for scripts generated by MT AG Ratingen                #
# ################################################################### #
# # Versions:                                                       # #
# ################################################################### #
# Ver. | Author     | Changes                            | Date       #
# ################################################################### #
# 0.1  | S.Josupeit | Initial Release                    | 29.07.2015 #
# 1.2  | S.Krieger  | Fertigstellung XML-Help-File       | 29.10.2015 #
# 1.3  | S.Krieger  | Erweiterungen                   ab | 30.10.2015 #
######################################################################>
#endregion

#region Version 1.2

#region Functions for CSOM

    #region Function Import-SPEDLL
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    Function Import-SPEDLL{
        [CmdletBinding()]
        param
        (
            [Parameter(Position=0,Mandatory=$true)]
            [System.String]
            $Path = $PathToSharePointDLLs,
            [Parameter(Position=1,Mandatory=$true)]
            [System.String]
            $File
        )
        Begin{}
        Process
        {
            $filePath = $Path.TrimEnd("\") + "\" + $File
            if(Test-Path $filePath)
            {
                try{
                   Add-Type -Path ($filePath)
                }
	            catch
	            {
                    if($global:ActivateTestLoggingException)
                    {
	                    $exMessage = $_.Exception.Message
	                    $innerException = $_.Exception.InnerException
	                    $info = "Fehler bei Import der DLL '" + $File + "' aus Ordner '" + $Path + "'"
	                    Push-SPEException -exMessage $exMessage -innerException $innerException -info $info
                    }
	            }
            } else {
                Write-SPELogMessage -level "Critical" -area "misc" -category "Adding" -message "DLL with path $filePath could not be found! Please check if folder $Path and file $File exists."
            }
        
        }
        End{}
    }
    #endregion
    #EndOfFunction

    #region Function Import-SPECsomDLLs
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    Function Import-SPECsomDLLs{
        [CmdletBinding()]
        param
        (
            [Parameter(Position=0)]
            [System.String]
            $Path,
            [Switch]$UseDocumentManagement,
            [Switch]$UsePublishing,
            [Switch]$UseSearch,
            [Switch]$UseSearchApplications,
            [Switch]$UseServerRuntime,
            [Switch]$UseTaxonomy,
            [Switch]$UseUserProfiles,
            [Switch]$UseWorkflowServices
        )
        Begin{
            if([String]::IsNullOrEmpty($Path))
            {
                $thisModulePath = (Get-Command $PSCmdlet.MyInvocation.MyCommand.Name.ToString()).Module.ModuleBase.ToString()
                $Path = $thisModulePath.TrimEnd("\") + "\"
            }
        }
        Process
        {
            $Path = $Path.TrimEnd("\") + "\"
            Add-Type -Path ($Path + "Microsoft.SharePoint.Client.dll")
            Add-Type -Path ($Path + "Microsoft.SharePoint.Client.Runtime.dll")
            if($UseDocumentManagement)
            {
                $file = "Microsoft.SharePoint.Client.DocumentManagement.dll"
                Import-SPEDLL -Path $Path -File $file
            }
            if($UsePublishing){
                $file = "Microsoft.SharePoint.Client.Publishing.dll"
                Import-SPEDLL -Path $Path -File $file
            }
            if($UseSearch) {
                $file = "Microsoft.SharePoint.Client.Search.dll"
                Import-SPEDLL -Path $Path -File $file
            }
            if($UseSearchApplications){
                $file = "Microsoft.SharePoint.Client.Search.Applications.dll"
                Import-SPEDLL -Path $Path -File $file
            }
            if($UseServerRuntime){
                $file = "Microsoft.SharePoint.Client.ServerRuntime.dll"
                Import-SPEDLL -Path $Path -File $file
            }
            if($UseTaxonomy){
                $file = "Microsoft.SharePoint.Client.Taxonomy.dll"
                Import-SPEDLL -Path $Path -File $file
            }
            if($UseUserProfiles){
                $file = "Microsoft.SharePoint.Client.UserProfiles.dll"
                Import-SPEDLL -Path $Path -File $file
            }
            if($UseWorkflowServices){
                $file = "Microsoft.SharePoint.Client.WorkflowServices.dll"
                Import-SPEDLL -Path $Path -File $file
            }
        }
        End{}
    }
   
    #endregion
    #EndOfFunction

    #region Function Get-SPECsomContext
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    function Get-SPECsomContext {
        [CmdletBinding()]
        param
        (
 		    [Parameter(Position=0, Mandatory=$true)]
		    [ValidateNotNullOrEmpty()]
		    [System.String]
		    $Url,
		    [Parameter(Position=1)]
		    [ValidateNotNull()]
		    [PSCredential]
		    $Credentials,
            [Switch]
            $SPO

       )

        begin 
        {
            Test-SPEAndLoadCsomDLLs
        }

        process 
        {
            if($SPO)
            {
                $credUsername = $Credentials.UserName
                $credSecPass = $Credentials.Password
                $cred = New-Object Microsoft.SharePoint.Client.SharePointOnlineCredentials($credUsername, $credSecPass)
            } else {
                $credUsername = $Credentials.GetNetworkCredential().UserName
                $credDomain = $Credentials.GetNetworkCredential().Domain
                $credSecPass = $Credentials.GetNetworkCredential().SecurePassword
                $cred = New-Object System.Net.NetworkCredential($credUsername, $credSecPass, $credDomain)
            }
            $ctx = New-Object Microsoft.SharePoint.Client.ClientContext($url)
            $ctx.Credentials = $cred

            if(!$ctx.ServerObjectIsNull.Value)
            {
                return $ctx
            }
            else
            {
                return $null
            }
        }
    }
    #endregion
    #EndOfFunction

    #region Function Get-SPECsomWeb
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    function Get-SPECsomWeb {
        [CmdletBinding()]
        param
        (
 		    [Parameter(Position=0, Mandatory=$true)]
		    [ValidateNotNullOrEmpty()]
		    [System.String]
		    $Url,
		    [Parameter(Position=1, Mandatory=$true)]
		    [ValidateNotNull()]
		    [PSCredential]
		    $Credentials,
            [Switch]
            $SPO
       )

        begin 
        {
            Test-SPEAndLoadCsomDLLs
        }

        process 
        {
            if($SPO)
            {
                $ctx = Get-SPECsomContext -Credentials $Credentials -Url $Url -SPO
            } else {
                $ctx = Get-SPECsomContext -Credentials $Credentials -Url $Url
            }
            if($ctx)
            {
                $web = $ctx.Web
                $ctx.Load($web)
                $ctx.ExecuteQuery()
                return $web
            }
            else
            {
                return $null
            }
        }
    }
    #endregion
    #EndOfFunction

    #region Function Get-SPECsomSite
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    function Get-SPECsomSite {
        [CmdletBinding()]
        param
        (
 		    [Parameter(Position=0, Mandatory=$true)]
		    [ValidateNotNullOrEmpty()]
		    [System.String]
		    $Url,
		    [Parameter(Position=1, Mandatory=$true)]
		    [ValidateNotNull()]
		    [PSCredential]
		    $Credentials,
            [Switch]$SPO

       )

        begin 
        {
            Test-SPEAndLoadCsomDLLs
        }

        process 
        {
            if($SPO)
            {
                $ctx = Get-SPECsomContext -Credentials $Credentials -Url $Url -SPO
            } else {
                $ctx = Get-SPECsomContext -Credentials $Credentials -Url $Url
            }
            if($ctx)
            {
                $site = $ctx.Site
                $ctx.Load($site)
                $ctx.ExecuteQuery()
                return $site
            }
            else
            {
                return $null
            }
        }
    }
    #endregion
    #EndOfFunction

    #region Function Get-SPECsomList
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    Function Get-SPECsomList
    {
        [CmdletBinding()]
        param
        (
		    [Parameter(Position=0, Mandatory=$true)]
		    [ValidateNotNull()]
		    [Microsoft.SharePoint.Client.Web]
		    $Web,
 		    [Parameter(Position=1)]
		    [System.String]
		    $ListTitle
        )
        begin 
        {
            Test-SPEAndLoadCsomDLLs
            $ctx = $web.Context
        }

        process 
        {
            if($ListTitle) # ListTitle is set, so return specified list
            {
                $list = $Web.Lists.GetByTitle($ListTitle)
                $ctx.Load($list)
                $ctx.ExecuteQuery()
                return $list

            }
            else # ListTitle is not set, so return all lists
            {
                $lists = $web.Lists
                $ctx.Load($lists)
                $ctx.ExecuteQuery()
                return $lists
            }
        }

    }
    #endregion
    #EndOfFunction

    #region Function Test-SPEAndLoadCsomDLLs
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    Function Test-SPEAndLoadCsomDLLs
    {
        [CmdletBinding()]
        param()
        Begin{}
        Process
        {
            try
            {
                #Testweise Erfassen, ob DLL Microsoft.SharePoint.Client geladen ist.
                [reflection.assembly]::GetAssembly("Microsoft.SharePoint.Client.ClientContext" -as [type]) | out-null
            }
            catch
            {
                #ist nicht geladen, also laden
                Import-SPECsomDLLs
            }
        }
        End{}
    }
    #endregion
    #EndOfFunction

    #region Function Get-SPECredentialsFromCurrentUser
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    Function Get-SPECredentialsFromCurrentUser
    {
        [CmdletBinding()]
        param
        (
            [Switch]$SPO
        )

        begin 
        {
        }
        process
        {
            if($SPO)
            {
                $EmailRegex = '^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,4})$'
                $message = "Bitte Web-Zugangsdaten (im Email-Format) eingeben"
                do{
                    $Credential = Get-Credential -Message $message
                    $message = "Anscheinend wurde der Anmeldename nicht im Email-Format eingegeben. Bitte erneut versuchen."
                } until($Credential.UserName -match $EmailRegex)
            } else {
                $currentUser = [Security.Principal.WindowsIdentity]::GetCurrent()
                $currentUserName = $currentUser.Name
                $Credential = Get-Credential -Message "Bitte Passwort eingeben" -UserName $currentUserName
            }
            return $Credential
        }

    }
    #endregion
    #EndOfFunction

    #region Function New-SPECsomList
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    Function New-SPECsomList {
        [CmdletBinding()]
        param
        (
		    [Parameter(Position=0, Mandatory=$true)]
		    [ValidateNotNull()]
		    [Microsoft.SharePoint.Client.Web]
		    $Web,
 		    [Parameter(Position=1, Mandatory=$true)]
		    [ValidateNotNullOrEmpty()]
		    [System.String]
		    $ListTitle,
 		    [Parameter(Position=2, Mandatory=$true)]
		    [ValidateNotNullOrEmpty()]
		    [System.String]
		    $ListDescription,
 		    [Parameter(Position=3, Mandatory=$true)]
		    [ValidateNotNullOrEmpty()]
		    [Int]
		    $ListTemplateId
       )

        begin 
        {
            Test-SPEAndLoadCsomDLLs
            $ctx = $web.Context
        }

        process 
        {
            try{
            $listCreationInfo = New-Object Microsoft.SharePoint.Client.ListCreationInformation
            $listCreationInfo.Title = $ListTitle
            $listCreationInfo.TemplateType = $ListTemplateId
            $list = $web.Lists.Add($listCreationInfo)
            $list.Description = $ListDescription
            $list.Update()
            $ctx.Load($list)
            $ctx.ExecuteQuery()
            return $list
            }
	        catch
	        {
                if($global:ActivateTestLoggingException)
                {
	                $exMessage = $_.Exception.Message
	                $innerException = $_.Exception.InnerException
	                $info = "Fehler bei Erzeugen einer neuen Liste mit Titel '" + $ListTitle + "' in Website '" + $Web.Url + "'."
	                Push-SPEException -exMessage $exMessage -innerException $innerException -info $info
                }
	        }
        }
    }
    #endregion
    #EndOfFunction

    #region Function New-SPECsomListItem
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    Function New-SPECsomListItem {
        [CmdletBinding()]
        param
        (
 		    [Parameter(Position=0, Mandatory=$true)]
		    [ValidateNotNullOrEmpty()]
		    [Microsoft.SharePoint.Client.List]
		    $List,

		    [Parameter(Position=1)]
		    [ValidateNotNull()]
		    [System.Collections.ArrayList]
		    $FieldValues
        )

        begin 
        {
            Test-SPEAndLoadCsomDLLs
            $ctx = $List.Context
        }

        process 
        {
            Write-host "ListTitle: '$($List.Title)'"
            $itemCreateInfo = New-Object Microsoft.SharePoint.Client.ListItemCreationInformation
            $newitem = $List.AddItem($itemCreateInfo)
            foreach($fieldValue in $FieldValues)
            {
                $newItem[$fieldValue.First] = $fieldValue.Second
            }
            $newItem.Update()
            $ctx.ExecuteQuery()
            return $newitem
        }
    }
    #endregion
    #EndOfFunction

    #region Function Get-SPECsomListItems
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    Function Get-SPECsomListItems
    {
        <#
        .SYNOPSIS
        Noch nicht fertig!!!

        #>
        [CmdletBinding()]
        param
        (
 		    [Parameter(Position=0, Mandatory=$true)]
		    [ValidateNotNullOrEmpty()]
		    [Microsoft.SharePoint.Client.List]
		    $List
        )

        begin 
        {
            Test-SPEAndLoadCsomDLLs
            $ctx = $List.Context
        }

        process 
        {
            $camlquery = [Microsoft.SharePoint.Client.CamlQuery]::CreateAllItemsQuery()
            $listItems = $list.GetItems($camlquery)
            $ctx.Load($listItems)
            $ctx.ExecuteQuery()
            return $listItems
        }
    }
    #endregion
    #EndOfFunction

    #region Function Get-SPECsomProperties
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    function Get-SPECsomProperties 
    { 
        [CmdletBinding(DefaultParameterSetName='ClientObject')] 
        param ( 
            # The Microsoft.SharePoint.Client.ClientObject to populate. 
            [Parameter(Mandatory = $true, ValueFromPipeline = $true, Position = 0, ParameterSetName = "ClientObject")] 
            [Microsoft.SharePoint.Client.ClientObject] 
            $object, 
            # The Microsoft.SharePoint.Client.ClientObject that contains the collection object. 
            [Parameter(Mandatory = $true, ValueFromPipeline = $true, Position = 0, ParameterSetName = "ClientObjectCollection")] 
            [Microsoft.SharePoint.Client.ClientObject] 
            $parentObject, 
            # The Microsoft.SharePoint.Client.ClientObjectCollection to populate. 
            [Parameter(Mandatory = $true, ValueFromPipeline = $true, Position = 1, ParameterSetName = "ClientObjectCollection")] 
            [Microsoft.SharePoint.Client.ClientObjectCollection] 
            $collectionObject, 
            # The object properties to populate 
            [Parameter(Mandatory = $true, Position = 1, ParameterSetName = "ClientObject")] 
            [Parameter(Mandatory = $true, Position = 2, ParameterSetName = "ClientObjectCollection")] 
            [string[]] 
            $propertyNames, 
            # The parent object's property name corresponding to the collection object to retrieve (this is required to build the correct lamda expression). 
            [Parameter(Mandatory = $true, Position = 3, ParameterSetName = "ClientObjectCollection")] 
            [string] 
            $parentPropertyName, 
            # If specified, execute the ClientContext.ExecuteQuery() method. 
            [Parameter(Mandatory = $false, Position = 4)] 
            [switch] 
            $executeQuery 
        ) 
        begin 
        {
            Test-SPEAndLoadCsomDLLs
        } 
        process { 
            if ($PsCmdlet.ParameterSetName -eq "ClientObject") { 
                $type = $object.GetType() 
            } else { 
                $type = $collectionObject.GetType() 
                if ($collectionObject -is [Microsoft.SharePoint.Client.ClientObjectCollection]) { 
                    $type = $collectionObject.GetType().BaseType.GenericTypeArguments[0] 
                } 
            } 
            $exprType = [System.Linq.Expressions.Expression] 
            $parameterExprType = [System.Linq.Expressions.ParameterExpression].MakeArrayType() 
            $lambdaMethod = $exprType.GetMethods() | ? { $_.Name -eq "Lambda" -and $_.IsGenericMethod -and $_.GetParameters().Length -eq 2 -and $_.GetParameters()[1].ParameterType -eq $parameterExprType } 
            $lambdaMethodGeneric = Invoke-Expression "`$lambdaMethod.MakeGenericMethod([System.Func``2[$($type.FullName),System.Object]])" 
            $expressions = @() 
  
            foreach ($propertyName in $propertyNames) { 
                $param1 = [System.Linq.Expressions.Expression]::Parameter($type, "p") 
                try 
                { 
                    $name1 = [System.Linq.Expressions.Expression]::Property($param1, $propertyName) 
                } 
                catch 
                { 
                    #Write-Error "Instance property '$propertyName' is not defined for type $type"
                    Write-SPELogMessage -level High -message "Instance property '$propertyName' is not defined for type $type"
                    return 
                } 
                $body1 = [System.Linq.Expressions.Expression]::Convert($name1, [System.Object]) 
                $expression1 = $lambdaMethodGeneric.Invoke($null, [System.Object[]] @($body1, [System.Linq.Expressions.ParameterExpression[]] @($param1))) 
                if ($collectionObject -ne $null) 
                { 
                    $expression1 = [System.Linq.Expressions.Expression]::Quote($expression1) 
                } 
                $expressions += @($expression1) 
            } 

            if ($PsCmdlet.ParameterSetName -eq "ClientObject") 
            { 
                $object.Context.Load($object, $expressions) 
                if ($executeQuery) { 
                    try{
                        $object.Context.ExecuteQuery() 
                    } 
                    catch 
                    {
                        if($global:ActivateTestLoggingException)
                        {
                            $exMessage = $_.Exception.Message
                            $innerException = $_.Exception.InnerException
                            $info = "Fehler bei ExecuteQuery in CmdLet 'Get-SPECsomProperties'"
                            Push-SPEException -exMessage $exMessage -innerException $innerException -info $info
                        }
                    }
                } 
            } 
            else 
            { 
                $newArrayInitParam1 = Invoke-Expression "[System.Linq.Expressions.Expression``1[System.Func````2[$($type.FullName),System.Object]]]" 
                $newArrayInit = [System.Linq.Expressions.Expression]::NewArrayInit($newArrayInitParam1, $expressions) 
                $collectionParam = [System.Linq.Expressions.Expression]::Parameter($parentObject.GetType(), "cp") 
                $collectionProperty = [System.Linq.Expressions.Expression]::Property($collectionParam, $parentPropertyName) 
                $expressionArray = @($collectionProperty, $newArrayInit) 
                $includeMethod = [Microsoft.SharePoint.Client.ClientObjectQueryableExtension].GetMethod("Include") 
                $includeMethodGeneric = Invoke-Expression "`$includeMethod.MakeGenericMethod([$($type.FullName)])" 
                $lambdaMethodGeneric2 = Invoke-Expression "`$lambdaMethod.MakeGenericMethod([System.Func``2[$($parentObject.GetType().FullName),System.Object]])" 
                $callMethod = [System.Linq.Expressions.Expression]::Call($null, $includeMethodGeneric, $expressionArray) 
                $expression2 = $lambdaMethodGeneric2.Invoke($null, @($callMethod, [System.Linq.Expressions.ParameterExpression[]] @($collectionParam))) 
                $parentObject.Context.Load($parentObject, $expression2) 
                if ($executeQuery) { $parentObject.Context.ExecuteQuery() } 
            } 
        } 
        end { } 
    } 
    #endregion
    #EndOfFunction

    #region Function Set-SPECsomWebProperties
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    function Set-SPECsomWebProperties
    {
        [CmdletBinding()]
        param
        (
		    [Parameter(Position=0, Mandatory=$true)]
		    [ValidateNotNull()]
		    [Microsoft.SharePoint.Client.Web]
		    $Web,
            [Parameter(Position=0, Mandatory=$true)]
            [ValidateNotNull()]
            [System.Collections.ArrayList]
            $Properties
        )
        Begin
        {
            Test-SPEAndLoadCsomDLLs
            #Prüfe, ob alle Properties vom Type System.Web.UI.Pair sind
            foreach($Property in $Properties)
            {
                $PropertyBaseTypeName = Get-SPEBaseTypeNameFromObject $Property
                if($PropertyBaseTypeName -ne "System.Web.UI.Pair")
                {
                    Write-SPELogMessage -level High -category Aborted -area WebSite -message "Fehler in Cmdlet 'Set-SPECSOMWebProperties'. Ein Item der anzugebenen ArrayList 'Properties' ist nicht vom Type 'System.Web.UI.Pair'."
                    break
                }
            }
        }
        Process
        {
            try
            {
                $context = $Web.Context
                $newPropertiesArrayList = new-Object System.Collections.ArrayList
                foreach($Property in $Properties)
                {
                    $PropertyName = $Property.First
                    $PropertyValue = $Property.Second
                    $web.($PropertyName) = $PropertyValue
                    $newPropertiesArrayList.Add($PropertyName)
                }
                $web.Update()
                Get-SPECSOMProperties -object $web -propertyNames ($newPropertiesArrayList.ToArray())
                $context.ExecuteQuery()
                return $web
            }
            catch
            {
                if($global:ActivateTestLoggingException)
                {
	                $exMessage = $_.Exception.Message
	                $innerException = $_.Exception.InnerException
	                $info = "Fehler in Cmdlet 'Set-SPECSOMWebProperties"
	                Push-SPEException -exMessage $exMessage -innerException $innerException -info $info
                }
            }
        }
        End{}
    }
    #endregion
    #EndOfFunction

#endregion


#region Functions for SharePoint

	#region Function Step-SPEThroughDirectorySubFolders
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
	Function Step-SPEThroughDirectorySubFolders
	{
		[CmdletBinding()]
		Param(
			[System.IO.DirectoryInfo]$directoryFolder,
			[Microsoft.SharePoint.SPFolder]$targetSPFolder
		)
		Begin{
			$directoryFolderPath = $directoryFolder.FullName
			#$folderRelativePath = $folderpath.Replace($directoryRoot,"")
		}
		Process{
			#region Copy current files from current directory
			$files = Get-SPEDirectoryFiles -folder $directoryFolder
			if($files)
			{
				$resultBasetype = Get-SPEBaseTypeNameFromObject -object $files
				switch($resultBasetype)
				{
					# variable $files contains multiple Items
					"Array"{	
						foreach($file in $files)
						{
							Copy-SPEFileFromDirectoryToSPFolder -sourceFile $file -directoryFolder $directoryFolder -targetSPFolder $targetSPFolder
						}
						break
					}
					# variable $files contains one single Item
					"FileSystemInfo"{ 
						$file = $files
						Copy-SPEFileFromDirectoryToSPFolder -sourceFile $file -directoryFolder $directoryFolder -targetSPFolder $targetSPFolder
						break
					}
					# something else resulting from an error
					"Default"{
						if($global:ActivateTestLoggingException){Write-SPELogMessage -message "An error occured at determination of files from folder '$directoryFolderPath'."}
						break
					}
				}
			}
			#endregion
				
			#region Iterating subfolders
			$directorySubFolders = Get-SPEDirectorySubfolders -folder $directoryFolder
				
			if($directorySubFolders)
			{
				$resultBasetype = Get-SPEBaseTypeNameFromObject -object $directorySubFolders
				switch($resultBasetype)
				{
					# variable $subFolders contains multiple Items
					"Array"{
						foreach($directorySubFolder in $directorySubFolders)
						{
							$subFolderName = $directorySubFolder.FullName.Split("\")[-1]
							if(($newSPFolder = Test-SPEAndSetSPFolder -subFolderName $subFolderName -parentSPFolder $targetSPFolder) -ne $null)
							{
								# Going one level deeper
								Step-SPEThroughDirectorySubFolders -directoryFolder $directorySubFolder -targetSPFolder $newSPFolder
							}
							else
							{
								if($global:ActivateTestLoggingException){Write-SPELogMessage -message "Error at determing subfolder '$subFolderName'. Skipping this Folder."}
							}
						}
						break
					}
					# variable $subFolders contains one single Item
					"FileSystemInfo"{ 
						$directorySubFolder = $directorySubFolders
						$subFolderName = $directorySubFolder.FullName.Split("\")[-1]
						if(($newSPFolder = Test-SPEAndSetSPFolder -subFolderName $subFolderName -parentSPFolder $targetSPFolder) -ne $null)
						{
							# Going one level deeper
							Step-SPEThroughDirectorySubFolders -directoryFolder $directorySubFolder -targetSPFolder $newSPFolder
						} else {
							if($global:ActivateTestLoggingException){Write-SPELogMessage -message "Error at determing subfolder '$subFolderName'. Skipping this Folder."}
						}
						break
					}
					# something else resulting from an error
					"Default"{
						if($global:ActivateTestLoggingException){Write-SPELogMessage -message "An error occured at determination of subfolders from folder '$directoryFolderPath'."}
						break
					}
				}
			}
			#endregion
		}
	}
	#endregion
    #EndOfFunction
		
	#region Function Test-SPEAndSetSPFolder
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
	Function Test-SPEAndSetSPFolder
	{
		[CmdletBinding()]
		Param(
			[String]$subFolderName,
			[Microsoft.SharePoint.SPFolder]$parentSPFolder
		)
		Begin{
		}
		Process{
			$newSPFolder = $null
			try
			{
				#$subFolderName = $directorySubFolder.Name
				Write-SPELogMessage -message "Testing for Subfolder '$subFolderName'..."
				if(($newSPFolder = $targetSPFolder.SubFolders[$subFolderName]) -eq $null){
					Write-SPELogMessage -message "...Folder does not exist and will be created."
					$newSPFolder = $targetSPFolder.SubFolders.Add($subFolderName)
					$newSPFolderURL = $newSPFolder.ServerRelativeUrl
					Write-SPEReportMessage -message "Created SPFolder '$newSPFolderURL'"
				} else {
					Write-SPELogMessage -message "...Folder exists an will be used."
				}
			}
	        catch
	        {
                if($global:ActivateTestLoggingException)
                {
	                $exMessage = $_.Exception.Message
	                $innerException = $_.Exception.InnerException
	                $info = "Error at Testing for SPFolder '$subFolderName'."
	                Push-SPEException -exMessage $exMessage -innerException $innerException -info $info
                }
	        }
			return $newSPFolder
				
		}
	}
	#endregion
    #EndOfFunction
		
	#region Function Copy-SPEFileFromDirectoryToSPFolder
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
	Function Copy-SPEFileFromDirectoryToSPFolder
	{
		[CmdletBinding()]
		Param(
			[System.IO.FileInfo]$sourceFile,
			[System.IO.DirectoryInfo]$directoryFolder,
			[Microsoft.SharePoint.SPFolder]$targetSPFolder
		)
		Begin{
		}
		Process{
			$fileName = $sourceFile.Name
			$filePath = $sourceFile.FullName
			$SPFolderUrl = $targetSPFolder.Url
			$dirPath = $directoryFolder.FullName
			$fileLastWriteTimeUTC = $sourceFile.LastWriteTimeUTC
			try{
				if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Found file '$filePath' in directory '$dirPath'."}
				if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Determing if file already exists in Library-Folder '$SPFolderUrl'..."}
				$doCopy = $true
				$doUpdate = $false
				if( ($spFile = $targetSPFolder.Files[$fileName]) -ne $null)
				{
					if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "File exists. Comparing 'Last Modification TimeStamps'..."}
					# file exists. check for lastmodified-property
					$spFileLastModified = $spFile.TimeLastModified
					if($spFileLastModified -gt $fileLastWriteTimeUTC)
					{
					    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Corresponding file to '$filePath' in SPFolder '$SPFolderUrl' is newer than the sourcefile."}
						if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Skipping copying the sourcefile."}
						$doCopy = $false
					} else {
						$doUpdate = $true
					}
				}
				if($doCopy){
					if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Copying file '$filePath' from directory '$dirPath' to SPFolder '$SPFolderUrl'..."}
					$fileStream = $sourceFile.OpenRead()
					[Microsoft.SharePoint.SPFile]$spFile = $targetSPFolder.Files.Add($SPFolderUrl + "/" + $fileName, $fileStream, $true)
					$fileStream.Close()
					if($doUpdate)
					{
						if($global:ActivateTestLoggingVerbose){Write-SPEReportMessage -message "Updated file '$filePath' from directory '$dirPath' to SPFolder '$SPFolderUrl'..."}
					}
					else
					{
						if($global:ActivateTestLoggingVerbose){Write-SPEReportMessage -message "Copied file '$filePath' from directory '$dirPath' to SPFolder '$SPFolderUrl'..."}
					}
				}
			}
			catch
	        {
                if($global:ActivateTestLoggingException)
                {
	                $exMessage = $_.Exception.Message
	                $innerException = $_.Exception.InnerException
	                $info = "Error at copying file '$filePath' from directory '$dirPath' to SPFolder '$SPFolderUrl'"
	                Push-SPEException -exMessage $exMessage -innerException $innerException -info $info
                }
	        }
		}
	}
	#endregion
    #EndOfFunction
		
	#region Function Remove-SPEEmptySPListSubfolders
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
	function Remove-SPEEmptySPListSubfolders
	{
        [CmdletBinding()]
        param
        (
			[Microsoft.SharePoint.SPFolder]$sourceFolder
		)

        begin {
        }

        process {
			Write-SPELogMessage -area "SPFolder" -category "Determining" -CorrelationId $CorrelationID -level "Verbose" -message "Prüfe, ob SPFolder '$($sourceFolder.Name)' leer ist und gelöscht werden kann."
			$folderRelativeUrl = $sourceFolder.ServerRelativeUrl
			$folderName = $sourceFolder.Name
			if(!($sourceFolder.ServerRelativeUrl -match "/Forms"))
			{
				$NoFilesInFolder = $false
				$NoSubFoldersInFolder = $false
				if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -area "SPItem" -category "Determining" -CorrelationId $CorrelationID -level "Verbose" -message "Prüfe, ob keine Items vorhanden sind..."}
				if($sourceFolder.Items.Count -eq 0)
				{
					if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -area "SPItem" -category "Determining" -CorrelationId $CorrelationID -level "Verbose" -message "Es sind keine Items vorhanden."}
					$NoFilesInFolder = $true
				}
				else 
				{
					if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -area "SPItem" -category "Determining" -CorrelationId $CorrelationID -level "Verbose" -message "Es sind Items vorhanden. Ordner kann nicht gelöscht werden."}
				}
				if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -area "SPFolder" -category "Determining" -CorrelationId $CorrelationID -level "Verbose" -message "Prüfe, ob keine SubFolders vorhanden sind..."}
				if($sourceFolder.SubFolders.Count -eq 0)
				{
					if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -area "SPFolder" -category "Determining" -CorrelationId $CorrelationID -level "Verbose" -message "Es sind keine SubFolder vorhanden."}
					$NoSubFoldersInFolder = $true
				} else {
					foreach($subFolder in $sourceFolder.SubFolders)
					{
						if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -area "SPFolder" -category "Determining" -CorrelationId $CorrelationID -level "Verbose" -message "Es sind SubFolder vorhanden. Iteriere tiefer..."}
						Remove-SPEEmptySPListSubfolders -sourceFolder $subFolder
						if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -area "SPFolder" -category "Determining" -CorrelationId $CorrelationID -level "Verbose" -message "Rücksprung nach Iteration. Überprüfe erneut auf vorhandene SubFolder..."}
						if($sourceFolder.subFolders.Count -eq 0)
						{
							if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -area "SPFolder" -category "Determining" -CorrelationId $CorrelationID -level "Verbose" -message "Keine weiteren SubFolder vorhanden."}
							$NoSubFoldersInFolder = $true
						}
						else
						{
							if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -area "SPFolder" -category "Determining" -CorrelationId $CorrelationID -level "Verbose" -message "Es sind weitere SubFolder vorhanden. Folder kann nicht gelöscht werden."}
						}
					}
				}
				if($NoFilesInFolder -and -$NoSubFoldersInFolder)
				{
					if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -area "SPFolder" -category "Removing" -CorrelationId $CorrelationID -level "Verbose" -message "Folder '$folderName' besitzt keine Items oder SubFolder und kann gelöscht werden."}
					$parentFolder = $sourceFolder.ParentFolder
					if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -area "SPFolder" -category "Removing" -CorrelationId $CorrelationID -level "Verbose" -message "Lösche Folder '$folderName'..."}
					if(!$TestModus)
					{
						$parentFolder.SubFolders.Delete($sourceFolder)
					}
					if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -area "SPFolder" -category "Removed" -CorrelationId $CorrelationID -level "Verbose" -message "Folder '$folderName' wurde gelöscht..."}
				}
			} else {
				if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -area "SPFolder" -category "Determining" -CorrelationId $CorrelationID -level "Medium" -message "Aktuelle Folder ist der FORMS-Folder"}
			}
		}
    }
	#endregion
    #EndOfFunction

	#region Function Compare-SPESPFolderWithDirectoryAndDeleteMatchesInSPFolder
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
	function Compare-SPESPFolderWithDirectoryAndDeleteMatchesInSPFolder
	{
        [CmdletBinding()]
        param
        (
			[Microsoft.SharePoint.SPFolder]$sourceFolder,
			[String]$directoryRoot
		)

        begin {
			$folderRelativeUrl = $sourceFolder.ServerRelativeUrl
        }

        process {
			if(!($sourceFolder.ServerRelativeUrl -match "/Forms"))
			{
				if($sourceFolder.Files.Count -gt 0)
				{
					$filesToDelete = New-Object System.Collections.ArrayList
					$files = $sourceFolder.Files
					foreach($file in $files)
					{
						$fileName = $file.name
						if($global:ActivateTestLoggingVerbose){Write-Host "filename to delete is $filename"}
						if(!(Test-SPESPFileExistsInDirectory -SPFile $file -directoryRoot $directoryRoot))
						{
							$fileName = $file.Name
							if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Collecting file '$fileName' for Deletion"}
							$filesToDelete.Add($file)
						}
					}
					if($filesToDelete.Count -gt 0)
					{
						foreach($file in $filesToDelete)
						{
							$fileName = $file.Name
							if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Deleting file '$fileName'..."}
							$sourceFolder.Files.Delete($file)
							if($global:ActivateTestLoggingVerbose){Write-SPEReportMessage -message "Deleted file '$fileName' from SPFolder '$folderRelativeUrl'"}
						}
					}
				}
				if($sourceFolder.SubFolders.Count -gt 0)
				{
					foreach($subFolder in $sourceFolder.SubFolders)
					{
						$subfolderSRU = $subFolder.ServerRelativeUrl
						Compare-SPESPFolderWithDirectoryAndDeleteMatchesInSPFolder -sourceFolder $subFolder -directoryRoot $directoryRoot
					}
				}
				if(!(Test-SPESPFolderExistsInDirectory -SPFolder $sourceFolder -directoryRoot $directoryRoot) -and ($sourceFolder.files -eq $null))
				{
					$folderName = $sourceFolder.Name
					$folderUrl = $sourceFolder.ServerRelativeUrl
					if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Folder '$folderName' does not exist in Directory and will now be deleted in Library."}
					$parentFolder = $sourceFolder.ParentFolder
					$parentFolder.SubFolders.Delete($sourceFolder)
					if($global:ActivateTestLoggingVerbose){Write-SPEReportMessage -message "Deleted SPFolder '$folderUrl'."}
				}
			} else {
				if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Current Folder is FORMS-Folder"}
			}
		}
    }
	#endregion
    #EndOfFunction

	#region Function Test-SPESPFileExistsInDirectory
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
	Function Test-SPESPFileExistsInDirectory
	{
		[CmdletBinding()]
		Param(
			[Microsoft.SharePoint.SPFile]$SPFile,
			[String]$directoryRoot
		)
		Begin{
			$relativeFilePath = $spFile.ServerRelativeUrl.TrimStart("/")
			$relativeFilePath = $relativeFilePath.Replace($dsTargetListName,"")
			if($dsTargetFolderListRelativePath -ne "/")
			{
				$relativeFilePath = $relativeFilePath.Replace($dsTargetFolderListRelativePath,"")
			}
			$relativeFilePath = $relativeFilePath.Replace("/","\")
			$fullFilePath = $dsSourceFolder + $relativeFilePath
		}
		Process{
			$fileExists = $false
			if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Determining if File '$fullFilePath' exists in directory..."}
			if((Test-Path -Path $fullFilePath))
			{
				$fileExists = $true
			}
			return $fileExists
		}
	}
	#endregion
    #EndOfFunction
		
	#region Function Test-SPESPFolderExistsInDirectory
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
	Function Test-SPESPFolderExistsInDirectory
	{
		[CmdletBinding()]
		Param(
			[Microsoft.SharePoint.SPFolder]$SPFolder,
			[String]$directoryRoot
		)
		Begin{
			$relativeFolderPath = $spFolder.ServerRelativeUrl.TrimStart("/")
			$relativeFolderPath = $relativeFolderPath.Replace($dsTargetListName,"")
			if($dsTargetFolderListRelativePath -ne "/")
			{
				$relativeFolderPath = $relativeFolderPath.Replace($dsTargetFolderListRelativePath,"")
			}
			$relativeFolderPath = $relativeFolderPath.Replace("/","\")
			$fullFolderPath = $dsSourceFolder + $relativeFolderPath
		}
		Process{
			if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Determining if Folder '$fullFolderPath' exists in Directory"}
			$folderExists = $false
			if((Test-Path -Path $fullFolderPath))
			{
				$folderExists = $true
			}
			return $folderExists
		}
	}
	#endregion
    #EndOfFunction
		
	#region Function Get-SPESPListSubfolders
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
	function Get-SPESPListSubfolders
	{
        [CmdletBinding()]
        param
        ([Microsoft.SharePoint.SPFolder]$folder)

        begin {
        }

        process {
			$subFolders = $null
			if($folder.Subfolders.Count -gt 0)
			{
				$subFolders = $folder.SubFolders
			}
			return $subFolders
		}
    }
	#endregion
    #EndOfFunction

	#region Function Test-SPEAndSetSPWeb
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
	function Test-SPEAndSetSPWeb
	{
#        EXAMPLE
#        $web = Test-SPEAndSetSPWeb -url "http://portal/website" -name "TestSite" -treeViewEnabled $false
        [CmdletBinding()]
        param
        (
			[String]$Url,
			[String]$Name,
            [String]$WebTemplate="STS#1",
			[Switch]$TreeViewEnabled,
            [Switch]$AddToQuickLaunch,
            [Switch]$UseParentTopNav
		)

        begin {
        }

        process {
			if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Prüfe WebSite $Url"}
			$web = Get-SPWeb $Url -ErrorAction SilentlyContinue
			if($web -eq $null)
			{
				if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "WebSite $Url existiert nicht und wird neu erstellt..."}
                $commandString = 'New-SPWeb -Url "' + $Url + '" -Template "' + $WebTemplate + '" -Name "' + $name + '"'
                if($AddToQuickLaunch)
                {
                    $commandString += ' -AddToQuickLaunch'
                }
                if($UseParentTopNav)
                {
                    $commandString += ' -UseParentTopNav'
                }
                Set-SPEVariable -VariableName newweb -CommandString
				if($treeViewEnabled)
				{
					$newweb.TreeViewEnabled = $true
				}
				$newweb.Update()
                $web = $newweb
                $newweb.Dispose()
				if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "...ZielWeb '$Url' wurde erstellt"}
			} else {
                if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "ZielWeb '$Url' existiert bereits und wird verwendet."}
            }
            $web
            $web.Dispose()
			return
		}
    }
	#endregion
    #EndOfFunction
		
	#region Function Remove-SPESPSubwebs
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
	function Remove-SPESPSubwebs
	{
        [CmdletBinding()]
        param
        ([Microsoft.SharePoint.SPWeb]$web)

        begin {
        }

        process {
			$WebUrl = $web.Url
			if($web.Webs.Count -gt 0)
			{
				if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Weitere SubWebSites vorhanden, iteriere tiefer...)"}
				foreach($subweb in $web.Webs)
				{
					Remove-SPESPSubwebs -web $subweb
				}
				if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "...Alle SubWebSites auf dieser Ebene gelöscht"}
			}
			Remove-SPWeb $webUrl -Confirm:$false
			if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "WebSite mit URL '$webUrl' gelöscht"}
		}
    }
	#endregion
    #EndOfFunction
	
	#region Function Copy-SPESPListViews
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
	function Copy-SPESPListViews
	{
        [CmdletBinding()]
        param
        (
		    [Microsoft.SharePoint.SPList]$sourceList,
		    [Microsoft.SharePoint.SPList]$targetList
	    )

        begin {
        }

        process {
			foreach($view in $sourceList.Views)
			{
				PauseOnKey
				$name = $view.title
				if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Kopiere View '$name'..."}
				$query = $view.Query
				$fieldsInternalNames = $view.ViewFields.ToStringCollection()
				#region Manipuliere FieldNamen
				$fieldsTitle = New-Object System.Collections.Specialized.StringCollection
				foreach($internalName in $fieldsInternalNames)
				{
					try
					{
						if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Erfasse Feld mit InternalName '$internalName'"}
						$field = $targetList.Fields.GetFieldByInternalName($internalName)
						if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "...Feld konnte erfasst werden."}
						$fieldTitle = $internalName
						if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Füge Feld '$fieldTitle' hinzu."}
						$cache = $fieldsTitle.Add($fieldTitle)
					}
				    catch
				    {
                        if($global:ActivateTestLoggingException){
				            $exMessage = $_.Exception.Message
				            $innerException = $_.Exception.InnerException
						    $targetListTitle = $targetList.Title
				            $info = "Fehler bei Kopieren von Views von Source-Liste '$sourceList' auf Target-Liste '$targetListTitle'."
						    if($innerException -match "does not exist. It may have been deleted by another user.")
						    {
							    #Feld existiert nicht
							    Write-SPELogMessage -message "Feld '$fieldTitle' existiert nicht auf Source-Liste '$sourceList'"
						    }
						    else
						    {
				                Push-SPEException -list $targetList -exMessage $exMessage -innerException $innerException -info $info
						    }
                        }
				    }
				}
				#endregion
				$isDefaultView = $view.DefaultView
				$paged = $view.paged
				$rowLimit = $view.RowLimit
				$type = $view.Type
				$personal = $view.PersonalView
					
				$newView = $targetList.Views.Add($name,$fieldsTitle,$query,$rowLimit,$paged,$isDefaultView,$type,$personal)
				$newView.Update()
				$targetList.Update()
				if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "... Kopieren des Views '$name' erfolgreich abgeschlossen."}
			}
		}
    }
	#endregion
    #EndOfFunction
	
	#region Function Copy-SPESPFolderProperties
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
	function Copy-SPESPFolderProperties
	{
        [CmdletBinding()]
        param
        (
		    [Microsoft.SharePoint.SPFolder]$sourceFolder,
		    [Microsoft.SharePoint.SPFolder]$targetFolder
	    )

        begin {
        }

        process {
			Wait-SPEOnKey
			if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Übertrage Feldwerte..."}
			$sourceFields = $sourceFolder.Item.Fields | ?{!($_.sealed)}
			foreach($field in $sourceFields)
			{
				$fieldTitle = $field.Title
				try
				{
					if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "...behandle Feld '$fieldTitle'..."}
					if($sourceFolder.Properties[$field.Title])
					{
						if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "...Feld ist nicht leer..."}
						if(!($targetFolder.Properties[$field.Title]))
						{
							if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "...Feld existiert nicht auf Zielordner und wird erstellt..."}
							$newPropCache = $targetFolder.AddProperty($field.Title, $sourceFolder.Properties[$field.Title])
							if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "...Feld wurde erfolgreich erstellt..."}
						} else {
							if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "...Feld existiert auf Zielordner und wird gefüllt..."}
							$targetFolder.Properties[$field.Title] = $sourceFolder.Properties[$field.Title]
							if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "...Feld erfolgreich gefüllt..."}
						}
					} else {
						if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "...Feld ist leer..."}
					}
				}
				catch
				{
                    if($global:ActivateTestLoggingException)
                    {
			            $exMessage = $_.Exception.Message
			            $innerException = $_.Exception.InnerException
					    if($exMessage -match "System.ArgumentException: Item has already been added. Key in dictionary")
                        {
				            $info = "Wert für Feld '$fieldTitle' scheint schon gesetzt zu sein. Füre Update aus."
				            Push-SPEException -exMessage $exMessage -innerException $innerException -info $info
						    $targetFolder.Properties[$field.Title] = $sourceFolder.Properties[$field.Title]
					    } else {
			                $info = "Fehler bei Übertrag des Feldwertes für Feld '$fieldTitle'"
			                Push-SPEException -exMessage $exMessage -innerException $innerException -info $info
					        Wait-SPEOnKey
					    }
                    }
				}
			}
		}
    }
	#endregion
    #EndOfFunction
		
	#region Function Copy-SPESPSubfolderItems
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
	function Copy-SPESPSubfolderItems
	{
        [CmdletBinding()]
        param
        (
	        [Microsoft.SharePoint.SPFolder]$sourceFolder,
	        [Microsoft.SharePoint.SPFolder]$targetFolder
        )

        begin {
        }

        process {
			$sourceFolderTitle = $sourceFolder.Name
			$targetFolderTitle = $targetFolder.Name
			if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Kopiere Dateien von Quellordner '$sourceFolderTitle' in Zielordner '$targetFolderTitle'"}
			$sourceWeb = $sourceFolder.ParentWeb
			$targetWeb = $targetFolder.ParentWeb
			$targetFolderFiles = $targetFolder.Files
			
			foreach($sourceFile in $sourceFolder.Files)
			{
				Wait-SPEOnKey
				$global:cntFiles++
				$fileSuccessfullyCopied = $false
				$sourceFileName = $sourceFile.Name
				try{
					if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "'$global:cntFiles' - Kopiere Datei '$sourceFileName' in Zielordner '$targetFolderTitle'..."}
					$destUrl = $targetFolder.Url + "/" + $sourceFileName
					$binFile = $sourceFile.OpenBinary()
					$targetFile = $targetFolderFiles.Add($destUrl, $binFile, $true)
                    
					if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "...Kopieren erfolgreich abgeschlossen."}
                    
					$fileSuccessfullyCopied = $true
                    
				}
				catch
				{
                    if($global:ActivateTestLoggingException)
                    {
		                $exMessage = $_.Exception.Message
		                $innerException = $_.Exception.InnerException
		                $info = "Fehler bei Kopieren des Files '$sourceFileName'"
		                Push-SPEException -exMessage $exMessage -innerException $innerException -info $info
					    Wait-SPEOnKey
                    }
				}
				if($fileSuccessfullyCopied){
					Write-SPELogMessage -message "Übertrage Feldwerte..."
					$sourceFields = $sourceFile.Item.Fields | ?{!($_.sealed)}
					foreach($field in $sourceFields)
					{
						$fieldTitle = $field.Title
						try
						{
							Write-SPELogMessage -message "...behandle Feld '$fieldTitle'..."
							if($sourceFile.Properties[$field.Title])
							{
								if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "...Feld ist nicht leer..."}
								if(!($targetFile.Properties[$field.Title]))
								{
									if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "...Feld existiert nicht auf Zieldatei und wird erstellt..."}
									$newPropCache = $targetFile.AddProperty($field.Title, $sourceFile.Properties[$field.Title])
									if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "...Feld wurde erfolgreich erstellt..."}
								} else {
									if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "...Feld existiert auf Zieldatei und wird gefüllt..."}
									$targetFile.Properties[$field.Title] = $sourceFile.Properties[$field.Title]
									if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "...Feld erfolgreich gefüllt..."}
								}
							} else {
								if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "...Feld ist leer..."}
							}
						}
						catch
						{
                            if($global:ActivateTestLoggingException)
                            {
				                $exMessage = $_.Exception.Message
				                $innerException = $_.Exception.InnerException
				                $info = "Fehler bei Übertrag des Feldwertes für Feld '$fieldTitle'"
				                Push-SPEException -exMessage $exMessage -innerException $innerException -info $info
							    Wait-SPEOnKey
                            }
						}
					}
					$targetFile.Update()
				} else {
					if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "...Lfd.Nr '$global:cntFiles' - Fehler bei Kopieren der Datei '$sourceFileName' in Zielordner '$targetFolderTitle'";}
				}
			}
			$targetWeb.Dispose();
			$sourceWeb.Dispose();
		}
    }
	#endregion
    #EndOfFunction
		
	#region Function Copy-SPESPColumnDefaultValue
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
	function Copy-SPESPColumnDefaultValue
	{
        [CmdletBinding()]
        param
        (
			[Microsoft.SharePoint.SPFolder]$sourceFolder,
			[Microsoft.SharePoint.SPFolder]$targetFolder
		)

        begin {
        }

        process {
			Wait-SPEOnKey
			$sourceFolderTitle = $sourceFolder.Name
			$sourceListId = $sourceFolder.ParentListId
			$sourceList = $sourceFolder.ParentWeb.Lists[$sourceListId]
			$sourceWebLanguageId = $sourceFolder.ParentWeb.Language
			$sourceDefaultMetadata = New-Object Microsoft.Office.DocumentManagement.MetadataDefaults($sourceList)
			$sourceFolderMetadataDefault = $sourceDefaultMetadata.GetDefaultMetadata($sourceFolder)
			
			$targetFolderTitle = $targetFolder.Name
			$targetListId = $targetFolder.ParentListId
			$targetList = $targetFolder.ParentWeb.Lists[$targetListId]
			$targetWebLanguageId = $targetFolder.ParentWeb.Language
			$targetDefaultMetadata = New-Object Microsoft.Office.DocumentManagement.MetadataDefaults($targetList)
			$targetFolderMetadataDefault = $targetDefaultMetadata.GetDefaultMetadata($targetFolder)
			
			
			foreach($ColumnDefaultValuePair in $sourceFolderMetadataDefault)
			{
				$columnName = $ColumnDefaultValuePair.First
				$columnValue = $ColumnDefaultValuePair.Second
				if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Setze Column Default Value für Folder '$targetFolderTitle' in Spalte '$columnName' mit Wert '$columnValue'"}
				$targetDefaultMetadata.SetFieldDefault($targetFolder, $columnName, $columnValue)
				$targetDefaultMetadata.Update()
				$columnValueString = $columnValue.Split('#')[1].Split('|')[0]
				Wait-SPEOnKey
			}
		}
    }
	#endregion
    #EndOfFunction

	#region Function Export-SPESPSiteColumns
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
	function Export-SPESPSiteColumns
	{
        [CmdletBinding()]
        param
        (
			[String]$xmlFilePath,
			[Microsoft.SharePoint.SPWeb]$web,
			[String]$groupName
		)

        begin {
        }

        process {
			New-Item $xmlFilePath -type file -Force
			Add-Content $xmlFilePath "<?xml version=`"1.0`" encoding=`"utf-8`"?>"
			Add-Content $xmlFilePath "`n<Fields>"
			$web.Fields | ForEach-Object{
				if($_.Group -eq $groupName)
				{
					Add-Content $xmlFilePath $_.SchemaXml
				}
			}
			Add-Content $xmlFilePath "`n</Fields>"
		}
    }
	#endregion
    #EndOfFunction
		
	#region Function Import-SPESPSiteColumns
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
	function Import-SPESPSiteColumns
	{
        [CmdletBinding()]
        param
        (
		    [Microsoft.SharePoint.SPWeb]$web,
		    [String]$xmlFilePath
	    )

        begin {
        }

        process {
			$fieldNameList = New-Object system.Collections.ArrayList
			$fieldsXml = [xml](Get-Content($xmlFilePath))
			#region Collect FieldNames
			$fieldsXML.Fields.Field | ForEach-Object {
				$cache = $fieldNameList.Add($_.DisplayName)
			}
			#endregion
			#region Create Fields based on XML
			$fieldsXML.Fields.Field | ForEach-Object {
			
			    #region Configure core properties belonging to all column types
			    $fieldXML = '<Field Type="' + $_.Type + '"
			    Name="' + $_.Name + '"
			    ID="' + $_.ID + '"
			    Description="' + $_.Description + '"
			    DisplayName="' + $_.DisplayName + '"
			    StaticName="' + $_.StaticName + '"
			    Group="' + $_.Group + '"
			    Hidden="' + $_.Hidden + '"
			    Required="' + $_.Required + '"
			    Sealed="' + $_.Sealed + '"'
			    #endregion
				
			    #region Configure optional properties belonging to specific column types  you may need to add some extra properties here if present in your XML file
			    if ($_.ShowInDisplayForm) { $fieldXML = $fieldXML + "`n" + 'ShowInDisplayForm="' + $_.ShowInDisplayForm + '"'}
			    if ($_.ShowInEditForm) { $fieldXML = $fieldXML + "`n" + 'ShowInEditForm="' + $_.ShowInEditForm + '"'}
			    if ($_.ShowInListSettings) { $fieldXML = $fieldXML + "`n" + 'ShowInListSettings="' + $_.ShowInListSettings + '"'}
			    if ($_.ShowInNewForm) { $fieldXML = $fieldXML + "`n" + 'ShowInNewForm="' + $_.ShowInNewForm + '"'}
			        
			    if ($_.EnforceUniqueValues) { $fieldXML = $fieldXML + "`n" + 'EnforceUniqueValues="' + $_.EnforceUniqueValues + '"'}
			    if ($_.Indexed) { $fieldXML = $fieldXML + "`n" + 'Indexed="' + $_.Indexed + '"'}
			    if ($_.Format) { $fieldXML = $fieldXML + "`n" + 'Format="' + $_.Format + '"'}
			    if ($_.MaxLength) { $fieldXML = $fieldXML + "`n" + 'MaxLength="' + $_.MaxLength + '"' }
			    if ($_.FillInChoice) { $fieldXML = $fieldXML + "`n" + 'FillInChoice="' + $_.FillInChoice + '"' }
			    if ($_.NumLines) { $fieldXML = $fieldXML + "`n" + 'NumLines="' + $_.NumLines + '"' }
			    if ($_.RichText) { $fieldXML = $fieldXML + "`n" + 'RichText="' + $_.RichText + '"' }
			    if ($_.RichTextMode) { $fieldXML = $fieldXML + "`n" + 'RichTextMode="' + $_.RichTextMode + '"' }
			    if ($_.IsolateStyles) { $fieldXML = $fieldXML + "`n" + 'IsolateStyles="' + $_.IsolateStyles + '"' }
			    if ($_.AppendOnly) { $fieldXML = $fieldXML + "`n" + 'AppendOnly="' + $_.AppendOnly + '"' }
			    if ($_.Sortable) { $fieldXML = $fieldXML + "`n" + 'Sortable="' + $_.Sortable + '"' }
			    if ($_.RestrictedMode) { $fieldXML = $fieldXML + "`n" + 'RestrictedMode="' + $_.RestrictedMode + '"' }
			    if ($_.UnlimitedLengthInDocumentLibrary) { $fieldXML = $fieldXML + "`n" + 'UnlimitedLengthInDocumentLibrary="' + $_.UnlimitedLengthInDocumentLibrary + '"' }
			    if ($_.CanToggleHidden) { $fieldXML = $fieldXML + "`n" + 'CanToggleHidden="' + $_.CanToggleHidden + '"' }
			    if ($_.List) { $fieldXML = $fieldXML + "`n" + 'List="' + $_.List + '"' }
			    if ($_.ShowField) { $fieldXML = $fieldXML + "`n" + 'ShowField="' + $_.ShowField + '"' }
			    if ($_.UserSelectionMode) { $fieldXML = $fieldXML + "`n" + 'UserSelectionMode="' + $_.UserSelectionMode + '"' }
			    if ($_.UserSelectionScope) { $fieldXML = $fieldXML + "`n" + 'UserSelectionScope="' + $_.UserSelectionScope + '"' }
			    if ($_.BaseType) { $fieldXML = $fieldXML + "`n" + 'BaseType="' + $_.BaseType + '"' }
			    if ($_.Mult) { $fieldXML = $fieldXML + "`n" + 'Mult="' + $_.Mult + '"' }
			    if ($_.ReadOnly) { $fieldXML = $fieldXML + "`n" + 'ReadOnly="' + $_.ReadOnly + '"' }
			    if ($_.FieldRef) { $fieldXML = $fieldXML + "`n" + 'FieldRef="' + $_.FieldRef + '"' }    
			    $fieldXML = $fieldXML + ">"
				#endregion
			    
			    #region Create choices if choice column
			    if ($_.Type -eq "Choice") {
			        $fieldXML = $fieldXML + "`n<CHOICES>"
			        $_.Choices.Choice | ForEach-Object {
			            $fieldXML = $fieldXML + "`n<CHOICE>" + $_ + "</CHOICE>"
			        }
			        $fieldXML = $fieldXML + "`n</CHOICES>"
			    }
			    #endregion
				
			    #region Set Default value, if specified  
			    if ($_.Default) { $fieldXML = $fieldXML + "`n<Default>" + $_.Default + "</Default>" }
			    #endregion
				
			    #region End XML tag specified for this field
			    $fieldXML = $fieldXML + "</Field>"
			    #endregion
				
			    #region Create column on the site
				try{
			    $web.Fields.AddFieldAsXml($fieldXML.Replace("&","&amp;"))
			    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Created site column" $_.DisplayName "on" $web.Url}
				}
		        catch
		        {
		            if($global:ActivateTestLoggingException)
                    {
                        $exMessage = $_.Exception.Message
		                $innerException = $_.Exception.InnerException
		                $info = "Fehler bei Erstellen einer SiteColumn"
					    if(!($innerException -match "A duplicate field name"))
					    {
    			            Push-SPEException -web $web -exMessage $exMessage -innerException $innerException -info $info
	    				}
                    }
		        }
				#endregion
			}
			#endregion
			return $fieldNameList
		}
    }
	#endregion
    #EndOfFunction
				
	#region Function Add-SPESPSiteColumnToSPContentType
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
	function Add-SPESPSiteColumnToSPContentType
    {
        [CmdletBinding()]
        param
        (
	        [Microsoft.SharePoint.SPWeb]$web,
	        [String]$fieldName,
	        [String]$contentTypeName
        )

        begin {
        }

        process {
			#Get SiteColumn as Field from WebSite
			$field = $web.Fields[$fieldName]
			#Get ContentType from WebSite
			$ct = $web.ContentTypes[$contentTypeName]
			#Create FieldLink for Field/SiteColumn
			$link = New-Object Microsoft.SharePoint.SPFieldLink($field)
			#Add FieldLink to ContentType
			$ct.FieldLinks.Add($link)
			#Update ContentType
			$ct.Update($true)
		}
    }
	#endregion
    #EndOfFunction
		
	#region Function Add-SPESPContentTypesToSPList
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
	function Add-SPESPContentTypesToSPList
	{
        [CmdletBinding()]
        param
        (
		    [System.Collections.ArrayList]$contentTypeNames,
		    [Microsoft.SharePoint.SPWeb]$targetWeb,
		    [Microsoft.SharePoint.SPList]$newList
	    )

        begin {
        }

        process {
		    foreach($ctName in $contentTypeNames)
		    {
			    try
			    {
				    $ctToAdd = $targetWeb.Site.RootWeb.ContentTypes[$ctName]
				    if($ctToAdd -ne $null){
					    $listCTs = $newList.ContentTypes
					    $ctExists = $false
					    foreach($listCT in $listCTs)
					    {
						    if($listCT.Name -eq $ctToAdd.Name)
						    {
							    $ctExists = $true
								    break
						    }
					    }
					    if(!$ctExists){
						    $ct = $newList.ContentTypes.Add($ctToAdd)
						    $output = "ContentType '" + $ctName + "' wurde der Liste '" + $newList.Title + "' hinzugefügt."
					    } else {
						    $output = "ContentType '" + $ctName + "' existiert bereits auf der Liste '" + $newList.Title + "'."
					    }
					    $newList.Update()
				    } else {
					    $output = "ContentType '" + $ctName + "' konnte nicht gefunden werden."
				    }
				    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message $output}
			    }
		        catch
		        {
		            if($global:ActivateTestLoggingException)
                    {
                        $exMessage = $_.Exception.Message
		                $innerException = $_.Exception.InnerException
		                $info = "Fehler bei Behandlung des ContentTypes $ctName"
				        if(!($innerException -match "A duplicate field name"))
				        {
			                Push-SPEException -list $newList.Title -web $targetWeb.Title -exMessage $exMessage -innerException $innerException -info $info
				        }
                    }
		        }
		    }
	    }
    }
	#endregion
    #EndOfFunction
	
    #region Function Export-SPESPList
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    function Export-SPESPList
    {
        [CmdletBinding()]
	    Param (
		    [parameter(Mandatory=$true)]
            [string]$WebUrl, 
		    [parameter(Mandatory=$true)]
            [string]$ListName,
		    [parameter(Mandatory=$true)]
            [string]$Path,
		    [parameter(Mandatory=$false)]
            [switch]$ExcludeDependencies,
		    [parameter(Mandatory=$false)]
            [switch]$HaltOnWarning,
		    [parameter(Mandatory=$false)]
            [switch]$HaltOnNonfatalError,
		    [parameter(Mandatory=$false)]
            [switch]$AutoGenerateDataFileName,
		    [parameter(Mandatory=$false)]
            [switch]$TestRun,
		    [parameter(Mandatory=$false)]
            [ValidateSet("None","All","WssOnly")]
            [string]$IncludeSecurity="None",
		    [parameter(Mandatory=$false)]
            [ValidateSet("LastMajor","All","CurrentVersion","LastMajorAndMinor")]
            [string]$IncludeVersions="LastMajor",
		    [parameter(Mandatory=$false)]
            [int]$FileMaxSize=0,
		    [parameter(Mandatory=$false)]
            [switch]$Overwrite
	    )
        Begin{
		    #Load SharePoint 2010 cmdlets
		    $ver = $host | select version
		    if ($ver.Version.Major -gt 1)  {$Host.Runspace.ThreadOptions = "ReuseThread"}
		    Add-PsSnapin Microsoft.SharePoint.PowerShell -ErrorAction SilentlyContinue
		    #Load assemblies (needed for SharePoint Server 2007)
#		    [void][System.Reflection.Assembly]::LoadWithPartialName("Microsoft.SharePoint")
		
 		    $site = New-Object Microsoft.SharePoint.SPSite($WebUrl)
		    $web = $site.OpenWeb()
		    $list = $web.Lists[$ListName]
		    [bool]$FileCompression = $false
       }
        Process{
		    #Set file paths for the export file and logs
		    [string]$exportPath = $Path.TrimEnd("\")
		    if ($exportPath.EndsWith(".cmp")) 
		    { 
			    $FileCompression = $true
			    $exportFile = $Path.Replace($Path.Remove($Path.LastIndexOf("\")+1),"")
			    $exportPath = $Path.Remove($Path.LastIndexOf("\"))
		    }
            if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Export-File created at $exportPath"}
		    $exportObject = New-Object Microsoft.SharePoint.Deployment.SPExportObject
		    $exportObject.Id = $list.ID
		    $exportObject.Type = [Microsoft.SharePoint.Deployment.SPDeploymentObjectType]::Site
	
		    #Create the export settings from the parameters specified
		    $exportSettings = New-Object Microsoft.SharePoint.Deployment.SPExportSettings
		    $exportSettings.SiteUrl = $site.Url
		    $exportSettings.ExportMethod = [Microsoft.SharePoint.Deployment.SPExportMethodType]::ExportAll
		    $exportSettings.FileLocation = $exportPath 
		    $exportSettings.FileCompression = $FileCompression 
		    if ($FileCompression) { $exportSettings.BaseFileName = $exportFile }
		    $exportSettings.ExcludeDependencies = $ExcludeDependencies
		    $exportSettings.OverwriteExistingDataFile = $Overwrite
		    $exportSettings.IncludeSecurity = $IncludeSecurity
		    $exportSettings.IncludeVersions = $IncludeVersions
		    $exportSettings.LogFilePath = $logFilePath
		    $exportSettings.HaltOnWarning = $HaltOnWarning
		    $exportSettings.HaltOnNonfatalError = $HaltOnNonfatalError
		    $exportSettings.AutoGenerateDataFileName = $AutoGenerateDataFileName
		    $exportSettings.TestRun = $TestRun
		    $exportSettings.FileMaxSize = $FileMaxSize
		    $exportSettings.ExportObjects.Add($exportObject)
	
		    #Write the export settings to a log file    
		    $outSiteUrl = $site.Url
            if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "SiteUrl = $outSiteUrl"}
            $outExportMethod = [Microsoft.SharePoint.Deployment.SPExportMethodType]::ExportAll
		    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "ExportMethod = $outExportMethod"}
		    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "FileLocation = $exportPath"}
		    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "FileCompression = $FileCompression"}
		    if ($FileCompression) { Write-SPELogMessage -message "BaseFileName = $exportFile" }
		    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "ExcludeDependencies = $ExcludeDependencies"}
		    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "OverwriteExistingDataFile = $Overwrite"}
		    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "IncludeSecurity = $IncludeSecurity"}
		    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "IncludeVersions = $IncludeVersions"}
		    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "LogFilePath = $logFilePath"}
		    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "HaltOnWarning = $HaltOnWarning"}
		    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "HaltOnNonfatalError = $HaltOnNonfatalError"}
		    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "AutoGenerateDataFileName = $AutoGenerateDataFileName"}
		    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "TestRun = $TestRun"}
		    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "FileMaxSize = $FileMaxSize"}
		    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "ExportObject = $exportObject"}
	
		    #Run the export procedure
		    $export = New-Object Microsoft.SharePoint.Deployment.SPExport($exportSettings)
		    # $exportSettings
		    # "Export läuft"
		    $export.Run()
		    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Export fertig"}
		
        }
        End{
		    #Dispose of the web and site objects after use
		    $web.Dispose()
		    $site.Dispose()
        }
    }
    #endregion
    #EndOfFunction

    #region Function Test-SPESPContentTypeIsInNewButton
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    Function Test-SPESPContentTypeIsInNewButton {
        [CmdletBinding()]
        Param ([parameter(Mandatory=$true)][string] $ContentTypeName,
               [parameter(Mandatory=$true)][Microsoft.SharePoint.SPList] $SPList)
        BEGIN
        {
            if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Prüfe, ob ContentType $ContentTypeName am New-Button der Liste $($SPList.Title) hinterlegt ist..." }
        }
        PROCESS{
            #get the uniquecontenttypes from the list root folder
            $rootFolder = $SPList.RootFolder
            $contentTypesInPlace = [Microsoft.SharePoint.SPContentType[]] $rootFolder.UniqueContentTypeOrder
             
            #Check if any of them are the same as the test content type
            $results = $contentTypesInPlace | where { $_.Name -eq $ContentTypeName} 
            if ($results -ne $null)
            {
                if($global:ActivateTestLoggingVerbose){Write-SPELogMessage "$ContentTypeName ist am New-Button der Liste $($SPList.Title) hinterlegt."}
                return $true
            }
            else
            {
                if($global:ActivateTestLoggingVerbose){Write-SPELogMessage "$ContentTypeName ist nicht am New-Button der Liste $($SPList.Title) hinterlegt."}
                return $false
            }
        }
        END
        {
            if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Prüfung, ob ContentType $ContentTypeName am New-Button der Liste $($SPList.Title) hinterlegt ist, abgeschlossen."}
        }
    }
    #endregion 
    #EndOfFunction

    #region Function Test-SPESPContentTypeIsInSPEList
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    Function Test-SPESPContentTypeIsInSPEList{
        [CmdletBinding()]
        Param ( [parameter(Mandatory=$true,ValueFromPipeline=$true)][string] $ContentTypeName,
               [parameter(Mandatory=$true)][Microsoft.SharePoint.SPList] $SPList)
 
        BEGIN   {
            if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Stelle sicher, ob ContentType(s) von Liste $($SPList.Title) referenziert wird/werden..." }
        }
        PROCESS { 
 
             #Check to see if the content type is already in the list
             $contentType = $SPList.ContentTypes[$ContentTypeName]
             if ($ContentType -ne $null)
             {
                #Content type already present
                if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "ContentType $ContentTypeName wird bereits von Liste $($SPList.Title) referenziert."}
                Return $true
             }
             else
             {
                if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "ContentType $ContentTypeName wird nicht von Liste $($SPList.Title). Füge ContentType hinzu..."}
                if (!$SPList.ContentTypesEnabled)
                {
                    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Die Nutzung von ContentTypes in Liste $($SPList.Title) ist deaktiviert. Aktiviere..."}
                    $SPList.ContentTypesEnabled = $true
                    $SPList.Update()
                }
                 #Add site content types to the list from the site collection root
                 $ctToAdd = $SPList.ParentWeb.Site.RootWeb.ContentTypes[$ContentTypeName]
                 if($ctToAdd -eq $null)
                 {
                    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "ContentType $ContentTypeName konnte nicht in der übergeordneten SiteCollection gefunden werden."}
                    #I don't believe this will be called.
                    return $false
                 }
                 $SPList.ContentTypes.Add($ctToAdd) | Out-Null
                 $SPList.Update()
                 if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "ContentType $ContentTypeName wurde der Liste $($SPList.Title) hinzugefügt."}
                 return $true
             }
            }
        END 
        {
            if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Sicherstellen, ob ContentType(s) von Liste $($SPList.Title) referenziert wird/werden, abgeschlossen."}
        }
    }
    #endregion 
    #EndOfFunction

    #region Function Set-SPESPContentTypeInNewButton
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    Function Set-SPESPContentTypeInNewButton{
    [CmdletBinding()]
    Param ( [parameter(Mandatory=$true,ValueFromPipeline=$true)][string] $ContentTypeName,
            [parameter(Mandatory=$true)][Microsoft.SharePoint.SPList] $SPList)
        BEGIN   { 
                    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Stelle sicher, ob ContentType(s) am New-Button der Liste $($SPList.Title) hinterlegt ist."}
                    #get the uniquecontenttypes from the list root folder
                    $contentTypesInPlace = New-Object 'System.Collections.Generic.List[Microsoft.SharePoint.SPContentType]'
                    $contentTypesInPlace = $SPList.RootFolder.UniqueContentTypeOrder
                    $dirtyFlag = $false
                }
        PROCESS { 
                 
            #Check the content type isn't already present in the content type
            $AlreadyPresent = Test-SPESPContentTypeIsInNewButton -ContentTypeName $ContentTypeName -SPList $SPList
            if ($AlreadyPresent)
            {
                if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "ContentType $ContentTypeName ist bereits am New-Button der Liste $($SPList.Title) hinterlegt."}
            }
            else
            {
                #Check that there really is such a content type
                $ContentTypePresent = Test-SPESPContentTypeIsInSPEList $ContentTypeName $SPList
                #Catch error events
                if ($ContentTypePresent)
                {
                    #We now know that the content type is not in the new button and is present in the list. Carry on adding the content type
                 
                    $ctToAdd = $SPList.ContentTypes[$ContentTypeName]
                 
                    #add our content type to the unique content type list
                    $contentTypesInPlace  =  $contentTypesInPlace + $ctToAdd
                    $dirtyFlag = $true
                    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "ContentType $ContentTypeName wurde der Liste der hinzuzufügenden ContentTypes hinzugefügt."}
                }
                else
                {
                    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "ContentType $ContentTypeName konnte nicht hinzugefügt werden."}
                }
            }
        }
        End{
            #Set the UniqueContentTypeOrder to the collection we made above
            if ($dirtyFlag)
            {
               $SPList = $SPList.ParentWeb.Lists[$SPList.ID]
                $rootFolder = $SPList.RootFolder
                $rootFolder.UniqueContentTypeOrder = [Microsoft.SharePoint.SPContentType[]]  $contentTypesInPlace
         
                 #Update the root folder
                 $rootFolder.Update()
                 if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "ContentType(s) wurde(n) dem New-button der Liste $($SPList.Title) hinzugefügt"}
            }
            else
            {
                    if($global:ActivateTestLoggingVerbose){Write-SPELogAndTextMessage -message "No changes"}
            }
            if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "sicherstellen von ContentType(s) am New-Button der Liste $($SPList.Title) abgeschlossen."}
        }
    }
    #endregion 
    #EndOfFunction

    #region Function Remove-SPESPContentTypeFromNewButton
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    Function Remove-SPESPContentTypeFromNewButton{
   [CmdletBinding()]
    Param ( [parameter(Mandatory=$true,ValueFromPipeline=$true)][string] $ContentTypeName,
            [parameter(Mandatory=$true)][Microsoft.SharePoint.SPList] $SPList)
     
    BEGIN   {if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Entferne ContentType(s) vom New-Button der Liste $($SPList.Title)..."}}
    PROCESS { 
    
                #Check the content type isn't already present in the content type
                $AlreadyPresent = Test-SPESPContentTypeIsInNewButton -ContentTypeName $ContentTypeName -SPList $SPList
                if ($AlreadyPresent)
                {
                    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "ContentType $ContentTypeName existiert am New-Button der Liste $($SPList.Title) und wird gelöscht..."}
                    #get the uniquecontenttypes from the list root folder
                    $rootFolder = $SPList.RootFolder
                 
                    #Get the content types where the names are different to our content type
                    $contentTypesInPlace = [System.Collections.ArrayList] $rootFolder.UniqueContentTypeOrder
                    $contentTypesInPlace = $contentTypesInPlace | where {$_.Name -ne $contentTypeName}
                 
                    #Set the UniqueContentTypeOrder to the collection we made above
                    $rootFolder.UniqueContentTypeOrder = [Microsoft.SharePoint.SPContentType[]]  $contentTypesInPlace
                 
                    #Update the root folder
                    $rootFolder.Update()
                    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "ContentType $ContentTypeName wurde vom New-Button der Liste $($SPList.Title) gelöscht."}
                }
                else
                {
                    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "ContentType $ContentTypeName existiert nicht am New-Button der Liste $($SPList.Title)."}
                }
            }
    END     {if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Entfernen von ContentType(s) vom New-Button der Liste $($SPList.Title) abgeschlossen."}}
 
    }
    #endregion 
    #EndOfFunction

    #region Function Remove-SPESPListView
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    function Remove-SPESPListView {
        [CmdletBinding()]
        Param(
            [Microsoft.SharePoint.SPList]$SPList,
            [string]$ViewName
        )
        Begin{}
        Process{
            $View = $List.Views[$ViewName]
            $List.Views.Delete($View.ID)
            $List.Update()
        }
        }
    #endregion
    #EndOfFunction

#endregion


#region Functions for SharePoint Online

    #region Function Get-SPESPOnlineCredentials
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    Function Get-SPESPOnlineCredentials
    {
        [CmdletBinding()]
        param
        (
        )

        begin 
        {
            Test-SPEAndLoadCsomDLLs
        }
        process
        {
            $Credential = Get-SPECredentialsFromCurrentUser -SPO
            $SPOCred = New-Object Microsoft.SharePoint.Client.SharePointOnlineCredentials($Credential.UserName, $Credential.Password)
            return $SPOCred
        }

    }
    #endregion
    #EndOfFunction

    #region Function Get-SPESPOnlineContext
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    function Get-SPESPOnlineContext {
        [CmdletBinding()]
        param
        (
 		    [Parameter(Position=0, Mandatory=$true)]
		    [ValidateNotNullOrEmpty()]
		    [System.String]
		    $Url,
		    [Parameter(Position=1)]
		    [ValidateNotNull()]
		    [Microsoft.SharePoint.Client.SharePointOnlineCredentials]
		    $Credentials,
            [Parameter(Position=2)]
            [Switch]$AsGlobal
       )

        begin 
        {
            Test-SPEAndLoadCsomDLLs
        }

        process 
        {
            if(!$Credentials -and !$global:cred)
            {
                $global:cred = Get-SPESPOnlineCredentials
                $Credentials = $cred
            }
            $ctx = New-Object Microsoft.SharePoint.Client.ClientContext($url)
            $ctx.Credentials = $Credentials

            if(!$ctx.ServerObjectIsNull.Value)
            {
                if($AsGlobal)
                {
                    $global:ctx = $ctx
                }
                return $ctx
            }
            else
            {
                return $null
            }
        }
    }
    #endregion
    #EndOfFunction
        
    #region Function Get-SPESPOnlineWeb
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    function Get-SPESPOnlineWeb {
        [CmdletBinding(DefaultParameterSetName="ByUrl")]
        param
        (
 		    [Parameter(Position=0, Mandatory=$true,ParameterSetName="ByUrl")]
		    [ValidateNotNullOrEmpty()]
		    [System.String]
		    $Url,
 		    [Parameter(Position=0, Mandatory=$true,ParameterSetName="ByContext")]
		    [ValidateNotNullOrEmpty()]
            [Microsoft.Sharepoint.Client.ClientContext]
            $Context,
		    [Parameter(Position=1)]
		    [Microsoft.SharePoint.Client.SharePointOnlineCredentials]
		    $Credentials
       )

        begin 
        {
            Test-SPEAndLoadCsomDLLs
        }

        process 
        {
            switch($PSCmdlet.ParameterSetName)
            {
                "ByUrl"{
                    $ctx = Get-SPESPOnlineContext -Url $url -Credentials $Credentials
                    if($ctx)
                    {
                        $web = $ctx.Web
                        $ctx.Load($web)
                        $ctx.ExecuteQuery()
                        return $web
                    }
                    else
                    {
                        return $null
                    }
                }
                "ByContext"{
                    $web = $ctx.Web
                    $ctx.Load($web)
                    $ctx.ExecuteQuery()
                    return $web
                }
            }
        }
    }
    #endregion
    #EndOfFunction

    #region Function Get-SPESPOnlineObjectByCtx
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    function Get-SPESPOnlineObjectByCtx {
        [CmdletBinding()]
        param
        (
            [Parameter(Position=0,Mandatory=$true)]
            [ValidateNotNullOrEmpty()]
            [PSObject]$ParentObject,
            [Parameter(Position=1,Mandatory=$false)]
            [ValidateNotNullOrEmpty()]
            $ChildObject,
            [Parameter(Position=2,Mandatory=$false)]
            [Microsoft.SharePoint.Client.ClientContext]$Ctx=$global:ctx
        )

        begin 
        {
            Test-SPEAndLoadCsomDLLs
        }

        process 
        {
            try
            {
                $objToLoad = $ParentObject.($ChildObject)
                $ctx.Load($objToLoad)
                $ctx.ExecuteQuery()
                return $objToLoad
            }
            catch
            {
                if($global:ActivateTestLoggingException)
                {
                    $exMessage = $_.Exception.Message
                    $innerException = $_.Exception.InnerException
                    $info = "Fehler bei Erfassen des ChildObjects '$ChildObject'"
                    Push-SPEException -exMessage $exMessage -innerException $innerException -info $info
                }
                return $null
            }
        }
    }
    #endregion
    #EndOfFunction

    #region Function Get-SPESPOnlineSubWebs
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    Function Get-SPESPOnlineSubWebs
    {
        [CmdletBinding()]
        param
        (
            [Parameter(Position=0,Mandatory=$true)]
            [ValidateNotNullOrEmpty()]
            [Microsoft.SharePoint.Client.Web]$web,
            [Parameter(Position=1,Mandatory=$false)]
            [Microsoft.SharePoint.Client.ClientContext]$Ctx=$global:ctx
        )
        Begin{
            Test-SPEAndLoadCsomDLLs
        }
        Process
        {
            try
            {
                if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Erfasse SubWebs von Website '$($web.title)'..."}
                $subwebs = Get-SPESPOnlineObjectByCtx -ParentObject $web -ChildObject "Webs"
                if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Es wurden $($subwebs.Count) SubWebs von Website '$($web.title)' erfasst."}
                return $subwebs
            }
            catch 
            {
                if($global:ActivateTestLoggingException)
                {
                    $exMessage = $_.Exception.Message
                    $innerException = $_.Exception.InnerException
                    $info = "Fehler bei Erfassen der SubWebs von Website '$($web.title)'"
                    Push-SPEException -exMessage $exMessage -innerException $innerException -info $info
                }
                return $null
            }
        }
    }
    #endregion
    #EndOfFunction
    
    #region Function Get-SPESPOnlineSubWebsIterative
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    Function Get-SPESPOnlineSubWebsIterative
    {
        [CmdletBinding()]
        param
        (
            [Parameter(Position=0,Mandatory=$true)]
            [ValidateNotNullOrEmpty()]
            [Microsoft.SharePoint.Client.Web]$web,
            [Parameter(Position=1,Mandatory=$false)]
            [Array]$properties,
            [Parameter(Position=2,Mandatory=$false)]
            [Microsoft.SharePoint.Client.ClientContext]$Ctx=$global:ctx

        )
        Begin{
            Test-SPEAndLoadCsomDLLs
        }
        Process
        {
            if($global:ActivateTestLogging){Write-SPELogMessage -message "Erfassung aller SubWebs von Website '$($web.title)' mit URL '$($web.Url)'..."}
            $collectedSubWebs = New-Object System.Collections.ArrayList
            if($global:ActivateTestLoggingVerbose){Write-SPELogAndTextMessage -message "aktueller Zähler collectedSubWebs: $($collectedSubWebs.Count)"}

            $subwebs = Get-SPESPOnlineSubWebs -web $web
            if($global:ActivateTestLoggingVerbose){Write-SPELogAndTextMessage -message "Es wurden $($subwebs.Count) SubWebs erfasst."}
            if($subwebs.Count -gt 0)
            {
                foreach($subweb in $subwebs)
                {
                    if(!$properties)
                    {
                        # Hole pauschal alle Properties des Web-Objects, die durch Get-SPECSOMProperties verarbeitet werden können.
                        $properties = $subweb | 
                            gm -force | 
                            ?{
                                $_.MemberType -eq "Property" -and 
                                $_.Name -ne "Context" -and 
                                $_.Name -ne "ObjectVersion" -and 
                                $_.Name -ne "Path" -and
                                $_.Name -ne "ServerObjectIsNull" -and
                                $_.Name -ne "Tag" -and
                                $_.Name -ne "TypedObject"
                            } | 
                            select name | 
                            %{$_.Name.ToString()}
                    }
                    $deeperSubWebs = Get-SPESPOnlineSubWebsIterative -web $subweb -properties $properties

                    #Get-SPECSOMProperties -object $subweb -propertyNames $properties -executeQuery
                    $collectedSubWebs.add($htweb) | out-null
                 }
            }
                   
            if($global:ActivateTestLogging){Write-SPELogAndTextMessage -message "Anzahl CollectedSubWebs: $($collectedSubWebs.Count)"}


            if($global:ActivateTestLogging){Write-SPELogMessage -message "Erfassung aller Subwebs von Website '$($web.title)' abgeschlossen."}
            return $collectedSubWebs
        }
    }
    #endregion
    #EndOfFunction

    #region Function Get-SPEObjectFromSPOnlineObject
    #.ExternalHelp SamsPowerShellEnhancements.psm1-help.xml
    Function Get-SPEObjectFromSPOnlineObject
    {
        [CmdletBinding()]
        param(
            [Parameter(Position=0,Mandatory=$false)]
            [Microsoft.SharePoint.Client.ClientContext]
            $Ctx,
            [Parameter(Position=1)]
            [ValidateNotNullOrEmpty()]
            $object,
            [Parameter(Position=2)]
            [String]
            $PropertyName,
            [Parameter(Position=3)]
            [Array]
            $PriorObjects,
            [Parameter(Position=4)]
            [int]
            $Level,
            [Parameter(Position=5)]
            [int]
            $CollectionCount,
            [Parameter(Position=6)]
            [int]
            $CollectionCurrent

        )
        Begin
        {
            Test-SPEAndLoadCsomDLLs
        }
        Process
        {
#            $textArray = @()
#            if($CollectionCount -and $CollectionCurrent)
#            {
#                $textArray += @(
#                    "CollectionItems : $CollectionCount",
#                    "Akt. Item Nr.   : $CollectionCurrent",
#                    ""
#                )
#            }
#            $textArray += @(
#                "Iterationstiefe : $Level",
#                "",
#                "PropertyName    : $PropertyName",
#                "",
#                "PriorObjects    :")
#            foreach($pObj in $PriorObjects)
#            {
#                $textArray += $pObj
#            }
            #Show-SPETextArray -textArray $textArray
#            $textMessage = ""
#            foreach($textString in $textArray)
#            {
#                $textMessage += $textString
#            }
            #Write-SPELogMessage -message $textMessage
            $Level++

            #region Parameter für Logging
            $curCorrId = $global:CorrelationId
            $fctCorrId = Set-SPEGuidIncrement4thBlock -guid $curCorrId
            #endregion
            if($PriorObjects -is [Array] -and !([String]::IsNullOrEmpty($PropertyName))) # -and $PriorObjects.Contains($PropertyName))
            {
                foreach($priorObject in $PriorObjects)
                {
                    $POName = $priorObject.Split(" - ")[0]
                    if($POName -eq $PropertyName)
                    {
                        return $null
                    }
                }
            } 
#            else 
#            {
                if(!($PriorObjects -is [Array]))
                {
                    $PriorObjects = @()
                    $PriorObjects = Get-SPEBaseTypeNameFromObject -object $object
                } else {
                    $PriorObjects += "$PropertyName - $CollectionCount - $CollectionCurrent"
                }
                $speObject = New-Object PsObject
                if((Get-SPEBaseTypeNameFromObject -object $object) -eq "Web")
                {
                    $speObject | Add-Member -MemberType NoteProperty -Name Context -Value $Ctx
                }

                #region Erfasse alle Properties
                $Properties = $object | gm -force | ?{$_.MemberType -eq "Property"} | ?{$_.Name.ToString() -ne ""} | select Name, Definition
                #endregion
                
                #region Erfasse Values der NON-SPC-Properties
                foreach($PropertyItem in $Properties)
                {
                    $fctCorrId = Set-SPEGuidIncrement4thBlock -guid $fctCorrId
  
                    $Property = $PropertyItem.Name.ToString()
                    $Definition = $PropertyItem.Definition.ToString()
                    if($Property -ne "TypedObject")
                    {
                        if($Definition.StartsWith("Microsoft.SharePoint.Client"))
                        {
                            try
                            {
                                $isComplexObject = $true
                                $childObject = Get-SPESPOnlineObjectByCtx -ParentObject $object -ChildObject $Property
                                if($childObject)
                                {
                                    if($Definition.Contains("Collection"))
                                    {
                                        $CurCollectionCount = $childObject.Count
                                        $collection = @()
                                        $collCnt = 0
                                        foreach($CollectionItem in $childObject)
                                        {
#                                            if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Schreibe SPC-Object '$Property'..." -level Verbose -CorrelationId $fctCorrId  -eventId $eventid -process $Property}
                                            $ChildObjects = Get-SPEObjectFromSPOnlineObject -object $childObject[$collCnt] -Ctx $Ctx -PropertyName $Property -PriorObjects $PriorObjects -Level $Level -CollectionCount $CurCollectionCount -CollectionCurrent $collCnt
                                            $collection += $ChildObjects
                                            $collCnt++
                                        }
                                        $speObject | Add-Member  -MemberType NoteProperty -Name $Property -Value $collection
                                        $collection.Clear()
                                    }
                                    else
                                    {
#                                        if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Schreibe SPC-Object '$Property'..." -level Verbose -CorrelationId $fctCorrId  -eventId $eventid -process $Property}
                                        $ChildObjects = Get-SPEObjectFromSPOnlineObject -object $childObject -Ctx $Ctx -PropertyName $Property -PriorObjects $PriorObjects -Level $Level
                                        $speObject | Add-Member  -MemberType NoteProperty -Name $Property -Value $ChildObjects
                                    }
                                }
                            }
                            catch
                            {
                                $isComplexObject = $false
                                #vielleicht doch ein Simple Object?
#                                if($global:ActivateTestLoggingException)
#                                {
#                                    $exMessage = $_.Exception.Message
#                                    $innerException = $_.Exception.InnerException
#                                    $info = "Fehler bei Erfassen des Property-Object '$Property_SPC'"
#                                    #Push-SPEException -exMessage $exMessage -innerException $innerException -info $info
#                                }
                            }
                            if($isComplexObject)
                            {
                                if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "...Schreiben von SPC-Object '$Property' erfolgreich abgeschlossen." -level Verbose -CorrelationId $fctCorrId  -eventId $eventid -process $Property}
                            }
                            else
                            {
                                try
                                {
#                                    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "SPC-Object '$Property' konnte nicht als Object erfasst werden. Versuche als SimpleObject zu erfassen..." -level High -CorrelationId $fctCorrId  -eventId $eventid -process $Property}
                                    $isSimpleObject = $true
                                    $speObject | Add-Member -Name $Property -Value $($object.($Property)) -MemberType NoteProperty
                                }
                                catch
                                {
                                    $isSimpleObject = $false
#                                    if($global:ActivateTestLoggingException)
#                                    {
#                                        $exMessage = $_.Exception.Message
#                                        $innerException = $_.Exception.InnerException
#                                        $info = "Fehler bei nachträglichem Erfassen des Property-Object '$Property' als SimpleObject"
#                                        #Push-SPEException -exMessage $exMessage -innerException $innerException -info $info
#                                    }
                                }
#                                if($isSimpleObject)
#                                {
#                                    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "...SPQ-Object '$Property' konnte als SimpleObject erfasst werden." -level Verbose -CorrelationId $fctCorrId  -eventId $eventid -process $Property}
#                                } 
#                                else
#                                {
#                                    if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "...SPQ-Object '$Property' konnte nicht erfasst werden." -level High -CorrelationId $fctCorrId  -eventId $eventid -process $Property}
#                                }
                    
                            }
                        }
                        else
                        {
                            try
                            {
#                                if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "Schreibe NON-SPC-Property '$Property'..." -CorrelationId $fctCorrId -eventId $eventid -process $Property}
                                $speObject | Add-Member -Name $Property -Value $($object.($Property)) -MemberType NoteProperty -force
#                                if($global:ActivateTestLoggingVerbose){Write-SPELogMessage -message "...Schreiben von NON-SPC-Property '$Property' abgeschlossen." -CorrelationId $fctCorrId -eventId $eventid -process $Property}
                            }
                            catch
                            {
#                                if($global:ActivateTestLoggingException)
#                                {
#                                    $exMessage = $_.Exception.Message
#                                    $innerException = $_.Exception.InnerException
#                                    $info = "Fehler bei direktem Erfassen des Property-Values '$Property' als SimpleObject"
#                                    Push-SPEException -exMessage $exMessage -innerException $innerException -info $info
#                                }
                            }
                        }
                    }
                }
                #endregion
                
                return $speObject
 #           }
        }
    }
    #endregion
    #EndOfFunction

    #region Function Get-SPESPOnlineLists
    Function Get-SPESPOnlineLists
    {
        [CmdletBinding()]
        param(
            [Parameter(
                Position=0, 
                Mandatory=$true , 
                ValueFromPipeline=$True, 
                ValueFromPipelinebyPropertyName=$True
            )]
            [Microsoft.SharePoint.Client.Web]
            $Web
        )
        Begin{
            Test-SPEAndLoadCsomDLLs
            $collectedLists = New-Object psobjectject
        }
        Process{
#            foreach($item in $web)
#            {
                $lists = Get-SPESPOnlineObjectByCtx -ParentObject $web -ChildObject "Lists"
                #return $lists
                foreach($list in $lists){
#                    $catchOut = $collectedLists.Add($list)
                    $collectedLists | Add-Member -MemberType NoteProperty -Name $($list.Title) -Value $list 
                }
#            }
        }
        End{
            return $collectedLists
        }
    }
    #endregion
    #EndOfFunction

#endregion


#endregion 

#EndOfFile